{"version":3,"sources":["../State.ts","../createHandler.ts","../node_modules/timers-browserify/main.js","../Directions.ts","../GestureHandlerRootView.tsx","../gestureHandlerRootHOC.tsx","../PlatformConstants.web.ts","../gestureHandlers.ts","../NativeViewGestureHandler.ts","../createNativeWrapper.tsx","../GestureHandlerButton.web.tsx","../GestureButtons.tsx","../TouchableNativeFeedback.tsx","../GenericTouchable.tsx","../TouchableWithoutFeedback.tsx","../TouchableOpacity.tsx","../TouchableHighlight.tsx","../GestureComponents.web.tsx","../Swipeable.tsx","../DrawerLayout.tsx","../node_modules/setimmediate/setImmediate.js","../node_modules/fbjs/lib/areEqual.js","../node_modules/invariant/browser.js","../../src/utils/assign.js","../../src/browser.js","../../src/utils/utils-consts.js","../../src/utils/prefixed.js","../../src/touchactionjs/get-touchaction-props.js","../../src/touchactionjs/touchaction-Consts.js","../../src/inputjs/input-consts.js","../../src/utils/each.js","../../src/utils/bool-or-fn.js","../../src/utils/in-str.js","../../src/touchactionjs/touchaction-constructor.js","../../src/touchactionjs/clean-touch-actions.js","../../src/utils/has-parent.js","../../src/inputjs/get-center.js","../../src/inputjs/simple-clone-input-data.js","../../src/inputjs/get-distance.js","../../src/inputjs/get-angle.js","../../src/inputjs/get-direction.js","../../src/inputjs/get-velocity.js","../../src/inputjs/compute-input-data.js","../../src/inputjs/compute-delta-xy.js","../../src/inputjs/get-scale.js","../../src/inputjs/get-rotation.js","../../src/inputjs/compute-interval-input-data.js","../../src/inputjs/input-handler.js","../../src/utils/split-str.js","../../src/utils/add-event-listeners.js","../../src/utils/remove-event-listeners.js","../../src/utils/get-window-for-element.js","../../src/inputjs/input-constructor.js","../../src/utils/in-array.js","../../src/input/pointerevent.js","../../src/utils/to-array.js","../../src/utils/unique-array.js","../../src/input/touch.js","../../src/input/mouse.js","../../src/input/touchmouse.js","../../src/utils/invoke-array-arg.js","../../src/recognizerjs/recognizer-consts.js","../../src/utils/unique-id.js","../../src/recognizerjs/get-recognizer-by-name-if-manager.js","../../src/recognizerjs/state-str.js","../../src/recognizerjs/recognizer-constructor.js","../../src/recognizers/tap.js","../../src/recognizers/attribute.js","../../src/recognizerjs/direction-str.js","../../src/recognizers/pan.js","../../src/recognizers/swipe.js","../../src/recognizers/pinch.js","../../src/recognizers/rotate.js","../../src/recognizers/press.js","../../src/defaults.js","../../src/manager.js","../../src/inputjs/create-input-instance.js","../../src/input/singletouch.js","../../src/utils/deprecate.js","../../src/utils/extend.js","../../src/utils/merge.js","../../src/utils/inherit.js","../../src/utils/bind-fn.js","../../src/hammer.js","../../src/index.js","../constants.ts","../Errors.ts","../NodeManager.ts","../GestureHandler.ts","../DraggingGestureHandler.ts","../utils.ts","../FlingGestureHandler.ts","../DiscreteGestureHandler.ts","../PressGestureHandler.ts","../LongPressGestureHandler.ts","../PanGestureHandler.ts","../IndiscreteGestureHandler.ts","../PinchGestureHandler.ts","../RotationGestureHandler.ts","../TapGestureHandler.ts","../RNGestureHandlerModule.web.ts"],"names":["State","UNDETERMINED","FAILED","BEGAN","CANCELLED","ACTIVE","END","findNodeHandle","Platform","node","findNodeHandleRN","UIManager","customGHEventsConfig","onGestureHandlerEvent","registrationName","onGestureHandlerStateChange","UIManagerConstants","setJSResponder","oldSetJSResponder","clearJSResponder","oldClearJSResponder","RNGestureHandlerModule","tag","handlerTag","handlerIDToTag","isConfigParam","param","Object","name","filterConfig","defaults","res","validProps","key","props","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Array","current","handle","handlerID","stateToPropMappings","createHandler","allowedProps","config","customNativeProps","constructor","event","state","stateEventName","eventHandler","ref","React","newConfig","newViewTag","Error","componentDidMount","extract","refs","r","hasUnresolvedRefs","this","setImmediate","transformProps","componentDidUpdate","viewTag","componentWillUnmount","clearImmediate","update","deepEqual","setNativeProps","mergedProps","updates","render","gestureEventHandler","onGestureEvent","gestureStateEventHandler","onHandlerStateChange","events","child","grandChildren","Touchable","color","hitSlop","collapsable","scope","global","self","window","apply","Function","prototype","Timeout","id","clearFn","_id","_clearFn","exports","setTimeout","call","arguments","clearTimeout","setInterval","clearInterval","timeout","close","unref","enroll","item","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","require","StyleSheet","container","flex","baseProps","TapGestureHandler","console","ForceTouchFallback","PanGestureHandler","validatePanGestureHandlerProps","transformPanGestureHandlerProps","nativeViewProps","NativeViewGestureHandler","NATIVE_WRAPPER_PROPS_FILTER","createNativeWrapper","ComponentWrapper","gestureHandlerProps","allowedKeys","_ref","useRef","_gestureHandlerRef","useImperativeHandle","Component","RawButton","accessibilityRole","shouldCancelWhenOutside","shouldActivateOnStart","nativeEvent","pointerInside","oldState","e","rest","rippleColor","processColor","AnimatedBaseButton","Animated","btnStyles","underlay","position","resolvedStyle","style","onActiveStateChange","opacity","backgroundColor","borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","RectButton","activeOpacity","underlayColor","BorderlessButton","borderless","TOUCHABLE_STATE","shouldCallOnPress","handlePressIn","time","delayPressIn","delayLongPress","handleMoveOutside","pressOutTimeout","handleGoToUndetermined","STATE","reset","moveToState","newState","onMoveIn","onMoveOut","coreProps","accessible","accessibilityLabel","accessibilityHint","accessibilityState","nativeID","onLayout","disallowInterruption","testID","GenericTouchable","extraButtonProps","TouchableWithoutFeedback","childStyle","toValue","duration","easing","Easing","useNativeDriver","to","onStateChange","children","TouchableOpacity","extraChildStyle","extraUnderlayStyle","renderChildren","TouchableHighlight","delayPressOut","ScrollView","TextInput","DrawerLayoutAndroid","RNDrawerLayoutAndroid","overshootFriction","leftWidth","rowWidth","rightOffset","rightWidth","Math","overshootLeft","overshootRight","transX","dragX","inputRange","outputRange","Number","extrapolate","ev","translationX","rowState","leftThreshold","rightThreshold","startOffsetX","velocityX","rowTranslation","restSpeedThreshold","restDisplacementThreshold","velocity","bounciness","animationOptions","finished","width","undefined","useNativeAnimations","UNSAFE_componentWillUpdate","friction","renderRightActions","renderLeftActions","styles","transform","translateX","leftActionTranslate","x","rightActionTranslate","activeOffsetX","enabled","onTapHandlerStateChange","pointerEvents","Swipeable","overflow","leftActions","flexDirection","I18nManager","rightActions","drawerType","touchX","containerWidth","drawerPosition","touchXValue","dragOffsetFromOnStartPosition","drawerWidth","gestureOptions","Keyboard","StatusBar","gestureStartX","dragOffsetBasedOnStart","showing","accessibilityViewIsModal","edgeWidth","fromLeft","gestureOrientation","minSwipeDistance","fromValue","nextFramePosition","willShow","speed","options","invariant","dynamicOverlayStyles","overlayColor","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","dynamicDrawerStyles","openValue","containerStyles","drawerTranslateX","closedDrawerOffset","drawerStyles","handleContainerLayout","importantForAccessibility","drawerTranslation","drawerShown","failOffsetY","enableTrackpadTwoFingerGesture","drawerLockMode","DrawerLayout","Left","Right","drawerContainer","zIndex","containerInFront","containerOnBack","absoluteFillObject","main","overlay","registerImmediate","nextHandle","tasksByHandle","currentlyRunningATask","doc","document","attachTo","getPrototypeOf","toString","process","nextTick","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","messagePrefix","random","onGlobalMessage","source","data","indexOf","slice","length","addEventListener","attachEvent","installPostMessageImplementation","MessageChannel","channel","port1","port2","installMessageChannelImplementation","createElement","html","documentElement","script","onreadystatechange","removeChild","appendChild","installReadyStateChangeImplementation","callback","args","i","task","run","aStackPool","bStackPool","eq","a","b","aStack","bStack","objToStr","className","String","isNaN","multiline","ignoreCase","push","size","hasOwnProperty","valueOf","keys","pop","module","result","condition","format","c","d","f","error","argIndex","replace","framesToPop","assign","target","TypeError","output","index","VENDOR_PREFIXES","TEST_ELEMENT","round","abs","now","Date","prefixed","obj","property","camelProp","prop","prefix","win","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MAP","touchMap","cssSupports","getTouchActionProps","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","MOBILE_REGEX","navigator","INPUT_TYPE_TOUCH","INPUT_TYPE_MOUSE","DIRECTION_DOWN","DIRECTION_VERTICAL","DIRECTION_UP","PROPS_XY","PROPS_CLIENT_XY","each","iterator","context","boolOrFn","val","inStr","str","find","TouchAction","set","manager","element","compute","actions","recognizer","hasPanX","hasPanY","cleanTouchActions","preventDefaults","input","srcEvent","direction","session","hasNone","isTapPointer","isTapMovement","isTapTouchTime","DIRECTION_LEFT","preventSrc","hasParent","parent","getCenter","pointers","pointersLength","y","simpleCloneInputData","clientX","clientY","timeStamp","center","deltaX","deltaY","getDistance","p1","p2","getAngle","getVelocity","deltaTime","computeInputData","firstInput","firstMultiple","offsetCenter","offset","prevDelta","prevInput","computeDeltaXY","getDirection","start","end","overallVelocity","getRotation","last","v","velocityY","computeIntervalInputData","srcEventTarget","inputHandler","eventType","pointersLen","changedPointersLen","isFirst","isFinal","splitStr","addEventListeners","types","handler","removeEventListeners","getWindowForElement","Input","init","destroy","inArray","src","findByKey","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","PointerEventInput","proto","store","removePointer","eventTypeNormalized","pointerType","isTouch","storeIndex","changedPointers","toArray","uniqueArray","sort","results","values","TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_TARGET_EVENTS","TouchInput","type","touches","getTouches","allTouches","targetIds","changedTouches","changedTargetTouches","targetTouches","touch","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","MouseInput","setLastTouch","eventData","lastTouch","lts","recordTouches","isSyntheticEvent","lastTouches","t","dx","dy","TouchMouseInput","inputData","isMouse","invokeArrayArg","arg","fn","STATE_FAILED","_uniqueId","getRecognizerByNameIfManager","otherRecognizer","stateStr","Recognizer","enable","touchAction","recognizeWith","simultaneous","dropRecognizeWith","requireFailure","requireFail","dropRequireFailure","hasRequireFailures","canRecognizeWith","emit","tryEmit","canEmit","recognize","inputDataClone","getTouchAction","TapRecognizer","taps","interval","threshold","posThreshold","validPointers","validMovement","validTouchTime","count","validInterval","pTime","validMultiTap","failTimeout","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","directionStr","PanRecognizer","DIRECTION_HORIZONTAL","directionTest","hasMoved","distance","SwipeRecognizer","PinchRecognizer","inOut","RotateRecognizer","PressRecognizer","validTime","domEvents","inputTarget","inputClass","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","preset","toggleCssProps","add","Manager","Type","stop","force","recognizers","curRecognizer","get","existing","remove","targetRecognizer","on","handlers","off","gestureEvent","triggerDomEvent","SINGLE_TOUCH_INPUT_MAP","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","normalizeSingleTouches","all","changed","deprecate","method","message","deprecationMessage","stack","log","extend","merge","dest","inherit","base","properties","baseP","childP","bindFn","Hammer","VERSION","DIRECTION_ALL","DIRECTION_RIGHT","DIRECTION_NONE","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","Tap","Pan","Swipe","Pinch","Rotate","Press","DEG_RAD","EventMap","Direction","RIGHT","LEFT","UP","DOWN","gestures","getHandler","gestureInstances","invokeNullableMethod","argMapping","nativeValue","gesture","rect","params","deltaRotation","failed","isDiscrete","shouldEnableGestureOnSetup","getConfig","onWaitingEnded","removePendingGesture","pendingGestures","addPendingGesture","isGestureEnabledForEvent","success","NativeGestureClass","updateHasCustomActivationCriteria","updateGestureConfig","asArray","NodeManager","configProps","ensureConfig","getState","transformEventData","numberOfPointers","maxPointers","changedTouch","isPointInView","transformNativeEvent","cancelPendingGestures","notifyPendingGestures","onGestureEnded","forceInvalidate","cancelEvent","onRawEvent","setView","setupEvents","onStart","rotation","onGestureActivated","onSuccess","_getPendingGestures","waitFor","filter","hasGestureFailed","getHammerConfig","minPointers","simulateCancelEvent","view","ratio","PixelRatio","__initialX","translationY","__initialY","absoluteX","absoluteY","isnan","isValidNumber","TEST_MIN_IF_NOT_NAN","limit","VEC_LEN_SQ","TEST_MAX_IF_NOT_NAN","max","fireAfterInterval","hammer","getTargetDirections","directions","Set","validPointerCount","shouldFailUnderCustomCriteria","pointerLength","maxDeltaX","maxDeltaY","maxDistSq","minDurationMs","maxDist","shouldDelayTouchForEvent","shouldDelayTouches","onGestureStart","sendGestureStartedEvent","isGestureRunning","nextState","previousState","minDist","horizontalDirections","verticalDirections","minDistSq","criteria","shouldActivateUnderCustomCriteria","shouldMultiFingerPanFail","deltaScale","scale","absDeltaRotation","hasCustomActivationCriteria","focalX","focalY","anchorX","anchorY","maxDelayMs","maxDurationMs","numberOfTaps","Gestures","RotationGestureHandler","PinchGestureHandler","LongPressGestureHandler","FlingGestureHandler","handleSetJSResponder","handleClearJSResponder","createGestureHandler","handlerName","attachGestureHandler","updateGestureHandler","getGestureHandlerNode","dropGestureHandler"],"mappings":"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","file":"static/js/7.5acfa756.chunk.js","sourcesContent":["// TODO use State from RNModule\n\nexport const State = {\n  UNDETERMINED: 0,\n  FAILED: 1,\n  BEGAN: 2,\n  CANCELLED: 3,\n  ACTIVE: 4,\n  END: 5,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type State = typeof State[keyof typeof State];\n","import * as React from 'react';\nimport {\n  findNodeHandle as findNodeHandleRN,\n  NativeModules,\n  Platform,\n  Touchable,\n} from 'react-native';\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\nimport { State } from '../State';\n\nimport {\n  BaseGestureHandlerProps,\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from './gestureHandlers';\nimport { ValueOf } from '../typeUtils';\n\nfunction findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nconst { UIManager = {} } = NativeModules;\n\nconst customGHEventsConfig = {\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange',\n  },\n};\n\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\n// native module.\n// Once new event types are registered with react it is possible to dispatch these\n// events to all kind of native views.\nUIManager.genericDirectEventTypes = {\n  ...UIManager.genericDirectEventTypes,\n  ...customGHEventsConfig,\n};\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\n// it compatible with RN 61+\nconst UIManagerConstants =\n  UIManager.getViewManagerConfig?.('getConstants') ??\n  UIManager.getConstants?.();\n\nif (UIManagerConstants) {\n  UIManagerConstants.genericDirectEventTypes = {\n    ...UIManagerConstants.genericDirectEventTypes,\n    ...customGHEventsConfig,\n  };\n}\n\n// Wrap JS responder calls and notify gesture handler manager\nconst {\n  setJSResponder: oldSetJSResponder = () => {\n    //no operation\n  },\n  clearJSResponder: oldClearJSResponder = () => {\n    //no operation\n  },\n} = UIManager;\nUIManager.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nlet handlerTag = 1;\nconst handlerIDToTag: Record<string, number> = {};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nfunction filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const res = { ...defaults };\n  validProps.forEach((key) => {\n    const value = props[key];\n    if (isConfigParam(value, key)) {\n      let value = props[key];\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof value !== 'object') {\n          value = { top: value, left: value, bottom: value, right: value };\n        }\n      }\n      res[key] = value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\n>;\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\n  props: HandlerProps<T>\n) {\n  // TODO(TS) - add type for extract arg\n  const extract = (refs: any | any[]) => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n    return refs.some((r) => r && r.current === null);\n  };\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nconst stateToPropMappings = {\n  [State.UNDETERMINED]: undefined,\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded',\n} as const;\n\ntype CreateHandlerArgs<\n  HandlerPropsT extends Record<string, unknown>\n> = Readonly<{\n  name: string;\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\n  config: Readonly<Record<string, unknown>>;\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\n  customNativeProps?: Readonly<string[]>;\n}>;\n\n// TODO(TS) fix event types\ntype InternalEventHandlers = {\n  onGestureHandlerEvent?: (event: any) => void;\n  onGestureHandlerStateChange?: (event: any) => void;\n};\n\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\nexport default function createHandler<\n  T extends BaseGestureHandlerProps<U>,\n  U extends Record<string, unknown>\n>({\n  name,\n  allowedProps = [],\n  config = {},\n  transformProps,\n  customNativeProps = [],\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\n  class Handler extends React.Component<T & InternalEventHandlers> {\n    static displayName = name;\n\n    private handlerTag: number;\n    private config: Record<string, unknown>;\n    private propsRef: React.MutableRefObject<unknown>;\n    private viewNode: any;\n    private viewTag?: number;\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\n\n    constructor(props: T & InternalEventHandlers) {\n      super(props);\n      this.handlerTag = handlerTag++;\n      this.config = {};\n      this.propsRef = React.createRef();\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(`Handler with ID \"${props.id}\" already registered`);\n        }\n        handlerIDToTag[props.id] = this.handlerTag;\n      }\n    }\n\n    componentDidMount() {\n      const props: HandlerProps<U> = this.props;\n      if (hasUnresolvedRefs(props)) {\n        // If there are unresolved refs (e.g. \".current\" has not yet been set)\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\n        // _update method that will try to update native handler props using\n        // setImmediate. This makes it so _update function gets called after all\n        // react components are mounted and we expect the missing ref object to\n        // be resolved by then.\n        this.updateEnqueued = setImmediate(() => {\n          this.updateEnqueued = null;\n          this.update();\n        });\n      }\n\n      this.createGestureHandler(\n        filterConfig(\n          transformProps ? transformProps(this.props) : this.props,\n          [...allowedProps, ...customNativeProps],\n          config\n        )\n      );\n\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\n    }\n\n    componentDidUpdate() {\n      const viewTag = findNodeHandle(this.viewNode);\n      if (this.viewTag !== viewTag) {\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\n      }\n      this.update();\n    }\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\n      if (this.updateEnqueued) {\n        clearImmediate(this.updateEnqueued);\n      }\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\n      const handlerID: string | undefined = this.props.id;\n      if (handlerID) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete handlerIDToTag[handlerID];\n      }\n    }\n\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onGestureEvent?.(event);\n      } else {\n        this.props.onGestureHandlerEvent?.(event);\n      }\n    };\n\n    // TODO(TS) - make sure this is right type for event\n    private onGestureHandlerStateChange = (\n      event: HandlerStateChangeEvent<U>\n    ) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onHandlerStateChange?.(event);\n\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\n        const stateEventName = stateToPropMappings[state];\n        const eventHandler = stateEventName && this.props[stateEventName];\n        if (eventHandler && typeof eventHandler === 'function') {\n          eventHandler(event);\n        }\n      } else {\n        this.props.onGestureHandlerStateChange?.(event);\n      }\n    };\n\n    private refHandler = (node: any) => {\n      this.viewNode = node;\n\n      const child = React.Children.only(this.props.children);\n      // TODO(TS) fix ref type\n      const { ref }: any = child;\n      if (ref !== null) {\n        if (typeof ref === 'function') {\n          ref(node);\n        } else {\n          ref.current = node;\n        }\n      }\n    };\n\n    private createGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.createGestureHandler(\n        name,\n        this.handlerTag,\n        newConfig\n      );\n    };\n\n    private attachGestureHandler = (newViewTag: number) => {\n      this.viewTag = newViewTag;\n\n      if (Platform.OS === 'web') {\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n          this.handlerTag,\n          newViewTag,\n          this.propsRef\n        );\n      } else {\n        RNGestureHandlerModule.attachGestureHandler(\n          this.handlerTag,\n          newViewTag\n        );\n      }\n    };\n\n    private updateGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\n    };\n\n    private update() {\n      const newConfig = filterConfig(\n        transformProps ? transformProps(this.props) : this.props,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      if (!deepEqual(this.config, newConfig)) {\n        this.updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates: any) {\n      const mergedProps = { ...this.props, ...updates };\n      const newConfig = filterConfig(\n        transformProps ? transformProps(mergedProps) : mergedProps,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      this.updateGestureHandler(newConfig);\n    }\n\n    render() {\n      let gestureEventHandler = this.onGestureHandlerEvent;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureEventHandlers = {\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\n      };\n      const {\n        onGestureEvent,\n        onGestureHandlerEvent,\n      }: OnGestureEventHandlers = this.props;\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerEvent) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureEventHandler = onGestureEvent;\n      } else {\n        if (\n          onGestureHandlerEvent &&\n          typeof onGestureHandlerEvent !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureStateChangeHandlers = {\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\n      };\n      const {\n        onHandlerStateChange,\n        onGestureHandlerStateChange,\n      }: OnGestureStateChangeHandlers = this.props;\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerStateChange) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureStateEventHandler = onHandlerStateChange;\n      } else {\n        if (\n          onGestureHandlerStateChange &&\n          typeof onGestureHandlerStateChange !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n      const events = {\n        onGestureHandlerEvent: gestureEventHandler,\n        onGestureHandlerStateChange: gestureStateEventHandler,\n      };\n\n      this.propsRef.current = events;\n\n      const child: any = React.Children.only(this.props.children);\n      let grandChildren = child.props.children;\n      if (\n        Touchable.TOUCH_TARGET_DEBUG &&\n        child.type &&\n        (child.type === 'RNGestureHandlerButton' ||\n          child.type.name === 'View' ||\n          child.type.displayName === 'View')\n      ) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(\n          Touchable.renderDebugView({\n            color: 'mediumspringgreen',\n            hitSlop: child.props.hitSlop,\n          })\n        );\n      }\n\n      return React.cloneElement(\n        child,\n        {\n          ref: this.refHandler,\n          collapsable: false,\n          ...events,\n        },\n        grandChildren\n      );\n    }\n  }\n  return Handler;\n}\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","export const Directions = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type Directions = typeof Directions[keyof typeof Directions];\n","import { View } from 'react-native';\n\nexport default View;\n","import * as React from 'react';\nimport { StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport GestureHandlerRootView from './GestureHandlerRootView';\n\nexport default function gestureHandlerRootHOC<P>(\n  Component: React.ComponentType<P>,\n  containerStyles?: StyleProp<ViewStyle>\n): React.ComponentType<P> {\n  function Wrapper(props: P) {\n    return (\n      <GestureHandlerRootView style={[styles.container, containerStyles]}>\n        <Component {...props} />\n      </GestureHandlerRootView>\n    );\n  }\n\n  Wrapper.displayName = `gestureHandlerRootHOC(${\n    Component.displayName || Component.name\n  })`;\n\n  hoistNonReactStatics(Wrapper, Component);\n\n  return Wrapper;\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n});\n","export default {\n  get forceTouchAvailable() {\n    return false;\n  },\n};\n","// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\n\nimport createHandler from './createHandler';\nimport PlatformConstants from '../PlatformConstants';\nimport { State } from '../State';\nimport { ValueOf } from '../typeUtils';\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = {\n  id?: string;\n  enabled?: boolean;\n  minPointers?: number;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?:\n    | number\n    // TODO(TS) take into consideration types from GestureHandler#setHitSlop\n    | Partial<\n        Record<\n          'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n          number\n        >\n      >\n    | Record<'width' | 'left', number>\n    | Record<'width' | 'right', number>\n    | Record<'height' | 'top', number>\n    | Record<'height' | 'bottom', number>;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nexport const baseProps = [\n  'id',\n  'enabled',\n  'minPointers',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport type TapGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface TapGestureHandlerProps\n  extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {\n  minPointers?: number;\n  maxDurationMs?: number;\n  maxDelayMs?: number;\n  numberOfTaps?: number;\n  maxDeltaX?: number;\n  maxDeltaY?: number;\n  maxDist?: number;\n}\n\nexport type TapGestureHandler = typeof TapGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const TapGestureHandler = createHandler<\n  TapGestureHandlerProps,\n  TapGestureHandlerEventPayload\n>({\n  name: 'TapGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'maxDurationMs',\n    'maxDelayMs',\n    'numberOfTaps',\n    'maxDeltaX',\n    'maxDeltaY',\n    'maxDist',\n    'minPointers',\n  ] as const,\n  config: {},\n});\n\nexport type FlingGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface FlingGestureHandlerProps\n  extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {\n  direction?: number;\n  numberOfPointers?: number;\n}\n\nexport type FlingGestureHandler = typeof FlingGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const FlingGestureHandler = createHandler<\n  FlingGestureHandlerProps,\n  FlingGestureHandlerEventPayload\n>({\n  name: 'FlingGestureHandler',\n  allowedProps: [...baseProps, 'numberOfPointers', 'direction'] as const,\n  config: {},\n});\n\nclass ForceTouchFallback extends React.Component {\n  static forceTouchAvailable = false;\n  componentDidMount() {\n    console.warn(\n      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'\n    );\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nexport type ForceTouchGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  force: number;\n};\n\nexport interface ForceTouchGestureHandlerProps\n  extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {\n  minForce?: number;\n  maxForce?: number;\n  feedbackOnActivation?: boolean;\n}\n\nexport type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {\n  forceTouchAvailable: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const ForceTouchGestureHandler = PlatformConstants?.forceTouchAvailable\n  ? createHandler<\n      ForceTouchGestureHandlerProps,\n      ForceTouchGestureHandlerEventPayload\n    >({\n      name: 'ForceTouchGestureHandler',\n      allowedProps: [\n        ...baseProps,\n        'minForce',\n        'maxForce',\n        'feedbackOnActivation',\n      ] as const,\n      config: {},\n    })\n  : ForceTouchFallback;\n\n(ForceTouchGestureHandler as ForceTouchGestureHandler).forceTouchAvailable =\n  PlatformConstants?.forceTouchAvailable || false;\n\nexport type LongPressGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface LongPressGestureHandlerProps\n  extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {\n  minDurationMs?: number;\n  maxDist?: number;\n}\n\nexport type LongPressGestureHandler = typeof LongPressGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const LongPressGestureHandler = createHandler<\n  LongPressGestureHandlerProps,\n  LongPressGestureHandlerEventPayload\n>({\n  name: 'LongPressGestureHandler',\n  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'] as const,\n  config: {},\n});\n\nfunction validatePanGestureHandlerProps(props: PanGestureHandlerProps) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props: PanGestureHandlerProps) {\n  type InternalPanGHKeys =\n    | 'activeOffsetXStart'\n    | 'activeOffsetXEnd'\n    | 'failOffsetXStart'\n    | 'failOffsetXEnd'\n    | 'activeOffsetYStart'\n    | 'activeOffsetYEnd'\n    | 'failOffsetYStart'\n    | 'failOffsetYEnd';\n  type PanGestureHandlerInternalProps = PanGestureHandlerProps &\n    Partial<Record<InternalPanGHKeys, number>>;\n\n  const res: PanGestureHandlerInternalProps = { ...props };\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props: PanGestureHandlerProps) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n\nexport type PanGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  translationX: number;\n  translationY: number;\n  velocityX: number;\n  velocityY: number;\n};\n\nexport interface PanGestureHandlerProps\n  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {\n  /** @deprecated  use activeOffsetX*/\n  minDeltaX?: number;\n  /** @deprecated  use activeOffsetY*/\n  minDeltaY?: number;\n  /** @deprecated  use failOffsetX*/\n  maxDeltaX?: number;\n  /** @deprecated  use failOffsetY*/\n  maxDeltaY?: number;\n  /** @deprecated  use activeOffsetX*/\n  minOffsetX?: number;\n  /** @deprecated  use failOffsetY*/\n  minOffsetY?: number;\n  activeOffsetY?: number | number[];\n  activeOffsetX?: number | number[];\n  failOffsetY?: number | number[];\n  failOffsetX?: number | number[];\n  minDist?: number;\n  minVelocity?: number;\n  minVelocityX?: number;\n  minVelocityY?: number;\n  minPointers?: number;\n  maxPointers?: number;\n  avgTouches?: boolean;\n  enableTrackpadTwoFingerGesture?: boolean;\n}\n\nexport type PanGestureHandler = typeof PanGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PanGestureHandler = createHandler<\n  PanGestureHandlerProps,\n  PanGestureHandlerEventPayload\n>({\n  name: 'PanGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'activeOffsetY',\n    'activeOffsetX',\n    'failOffsetY',\n    'failOffsetX',\n    'minDist',\n    'minVelocity',\n    'minVelocityX',\n    'minVelocityY',\n    'minPointers',\n    'maxPointers',\n    'avgTouches',\n    'enableTrackpadTwoFingerGesture',\n  ] as const,\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: [\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'failOffsetYStart',\n    'failOffsetYEnd',\n    'failOffsetXStart',\n    'failOffsetXEnd',\n  ],\n});\n\nexport type PinchGestureHandlerEventPayload = {\n  scale: number;\n  focalX: number;\n  focalY: number;\n  velocity: number;\n};\n\nexport interface PinchGestureHandlerProps\n  extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {}\n\nexport type PinchGestureHandler = typeof PinchGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PinchGestureHandler = createHandler<\n  PinchGestureHandlerProps,\n  PinchGestureHandlerEventPayload\n>({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n\nexport type RotationGestureHandlerEventPayload = {\n  rotation: number;\n  anchorX: number;\n  anchorY: number;\n  velocity: number;\n};\n\nexport interface RotationGestureHandlerProps\n  extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {}\n\nexport type RotationGestureHandler = typeof RotationGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const RotationGestureHandler = createHandler<\n  RotationGestureHandlerProps,\n  RotationGestureHandlerEventPayload\n>({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n","import DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport * as NodeManager from './NodeManager';\nimport PressGestureHandler from './PressGestureHandler';\nimport { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\n\nclass NativeViewGestureHandler extends PressGestureHandler {\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (!ev.isFinal) {\n      // if (this.ref instanceof ScrollView) {\n      if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({ x: ev.deltaX, y: ev.deltaY }), 10)) {\n        // @ts-ignore FIXME(TS) config type\n        if (this.config.disallowInterruption) {\n          const gestures = Object.values(NodeManager.getNodes()).filter(\n            (gesture) => {\n              const { handlerTag, view, isGestureRunning } = gesture;\n              return (\n                // Check if this gesture isn't self\n                handlerTag !== this.handlerTag &&\n                // Ensure the gesture needs to be cancelled\n                isGestureRunning &&\n                // ScrollView can cancel discrete gestures like taps and presses\n                gesture instanceof DiscreteGestureHandler &&\n                // Ensure a view exists and is a child of the current view\n                view &&\n                // @ts-ignore FIXME(TS) view type\n                this.view.contains(view)\n              );\n            }\n          );\n          // Cancel all of the gestures that passed the filter\n          for (const gesture of gestures) {\n            // TODO: Bacon: Send some cached event.\n            gesture.forceInvalidate(ev);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default NativeViewGestureHandler;\n","import * as React from 'react';\nimport { useImperativeHandle, useRef } from 'react';\n\nimport {\n  NativeViewGestureHandler,\n  NativeViewGestureHandlerProps,\n  nativeViewProps,\n} from './NativeViewGestureHandler';\n\n/*\n * This array should consist of:\n *   - All keys in propTypes from NativeGestureHandler\n *     (and all keys in GestureHandlerPropTypes)\n *   - 'onGestureHandlerEvent'\n *   - 'onGestureHandlerStateChange'\n */\nconst NATIVE_WRAPPER_PROPS_FILTER = [\n  ...nativeViewProps,\n  'onGestureHandlerEvent',\n  'onGestureHandlerStateChange',\n] as const;\n\nexport default function createNativeWrapper<P>(\n  Component: React.ComponentType<P>,\n  config: Readonly<NativeViewGestureHandlerProps> = {}\n) {\n  const ComponentWrapper = React.forwardRef<\n    React.ComponentType<any>,\n    P & NativeViewGestureHandlerProps\n  >((props, ref) => {\n    // filter out props that should be passed to gesture handler wrapper\n    const gestureHandlerProps = Object.keys(props).reduce(\n      (res, key) => {\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\n        if (allowedKeys.includes(key)) {\n          // @ts-ignore FIXME(TS)\n          res[key] = props[key];\n        }\n        return res;\n      },\n      { ...config } // watch out not to modify config\n    );\n    const _ref = useRef<React.ComponentType<P>>();\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\n    useImperativeHandle(\n      ref,\n      // @ts-ignore TODO(TS) decide how nulls work in this context\n      () => {\n        const node = _gestureHandlerRef.current;\n        // add handlerTag for relations config\n        if (_ref.current && node) {\n          // @ts-ignore FIXME(TS) think about createHandler return type\n          _ref.current.handlerTag = node.handlerTag;\n          return _ref.current;\n        }\n        return null;\n      },\n      [_ref, _gestureHandlerRef]\n    );\n    return (\n      <NativeViewGestureHandler\n        {...gestureHandlerProps}\n        // @ts-ignore TODO(TS)\n        ref={_gestureHandlerRef}>\n        <Component {...props} ref={_ref} />\n      </NativeViewGestureHandler>\n    );\n  });\n\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\n\n  return ComponentWrapper;\n}\n","import * as React from 'react';\nimport { View } from 'react-native';\n\nexport default React.forwardRef<View>((props, ref) => (\n  <View ref={ref} accessibilityRole=\"button\" {...props} />\n));\n","import * as React from 'react';\nimport {\n  Animated,\n  Platform,\n  processColor,\n  StyleSheet,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\nimport GestureHandlerButton from './GestureHandlerButton';\nimport { State } from '../State';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../handlers/gestureHandlers';\nimport {\n  NativeViewGestureHandlerPayload,\n  NativeViewGestureHandlerProps,\n} from '../handlers/NativeViewGestureHandler';\n\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\n  exclusive?: boolean;\n  // TODO: we should transform props in `createNativeWrapper`\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\n}\n\nexport interface BaseButtonProps extends RawButtonProps {\n  onPress?: (pointerInside: boolean) => void;\n  onActiveStateChange?: (active: boolean) => void;\n  style?: StyleProp<ViewStyle>;\n  testID?: string;\n}\n\nexport interface RectButtonProps extends BaseButtonProps {\n  underlayColor?: string;\n  activeOpacity?: number;\n}\n\nexport interface BorderlessButtonProps extends BaseButtonProps {\n  borderless?: boolean;\n  activeOpacity?: number;\n}\n\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: false,\n});\n\nexport class BaseButton extends React.Component<BaseButtonProps> {\n  private lastActive: boolean;\n\n  constructor(props: BaseButtonProps) {\n    super(props);\n    this.lastActive = false;\n  }\n\n  private handleEvent = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state, oldState, pointerInside } = nativeEvent;\n    const active = pointerInside && state === State.ACTIVE;\n\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\n      this.props.onActiveStateChange(active);\n    }\n\n    if (\n      oldState === State.ACTIVE &&\n      state !== State.CANCELLED &&\n      this.lastActive &&\n      this.props.onPress\n    ) {\n      this.props.onPress(active);\n    }\n\n    this.lastActive = active;\n  };\n\n  // Normally, the parent would execute it's handler first,\n  // then forward the event to listeners. However, here our handler\n  // is virtually only forwarding events to listeners, so we reverse the order\n  // to keep the proper order of the callbacks (from \"raw\" ones to \"processed\").\n  private onHandlerStateChange = (\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onHandlerStateChange?.(e);\n    this.handleEvent(e);\n  };\n\n  private onGestureEvent = (\n    e: GestureEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onGestureEvent?.(e);\n    this.handleEvent(\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n    ); // TODO: maybe it is not correct\n  };\n\n  render() {\n    const { rippleColor, ...rest } = this.props;\n\n    return (\n      <RawButton\n        rippleColor={processColor(rippleColor)}\n        {...rest}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}\n      />\n    );\n  }\n}\n\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\n\nconst btnStyles = StyleSheet.create({\n  underlay: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: 0,\n  },\n});\n\nexport class RectButton extends React.Component<RectButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.105,\n    underlayColor: 'black',\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: RectButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(0);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\n\n    return (\n      <BaseButton\n        {...rest}\n        style={resolvedStyle}\n        onActiveStateChange={this.onActiveStateChange}>\n        <Animated.View\n          style={[\n            btnStyles.underlay,\n            {\n              opacity: this.opacity,\n              backgroundColor: this.props.underlayColor,\n              borderRadius: resolvedStyle.borderRadius,\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\n            },\n          ]}\n        />\n        {children}\n      </BaseButton>\n    );\n  }\n}\n\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.3,\n    borderless: true,\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: BorderlessButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(1);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    return (\n      <AnimatedBaseButton\n        {...rest}\n        onActiveStateChange={this.onActiveStateChange}\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\n        {children}\n      </AnimatedBaseButton>\n    );\n  }\n}\n\nexport { default as PureNativeButton } from './GestureHandlerButton';\n","import { TouchableNativeFeedback } from 'react-native';\n\nexport default TouchableNativeFeedback;\n","import * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  Platform,\n  StyleProp,\n  ViewStyle,\n  TouchableWithoutFeedbackProps,\n} from 'react-native';\n\nimport { State } from '../../State';\nimport { BaseButton } from '../GestureButtons';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../../handlers/gestureHandlers';\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\n\n/**\n * Each touchable is a states' machine which preforms transitions.\n * On very beginning (and on the very end or recognition) touchable is\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\n * finishes in UNDETERMINED state.\n */\nexport const TOUCHABLE_STATE = {\n  UNDETERMINED: 0,\n  BEGAN: 1,\n  MOVED_OUTSIDE: 2,\n} as const;\n\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\n\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\n  // Decided to drop not used fields from RN's implementation.\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\n\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\n  onPress?: () => void;\n  onPressIn?: () => void;\n  onPressOut?: () => void;\n  onLongPress?: () => void;\n\n  nativeID?: string;\n  shouldActivateOnStart?: boolean;\n  disallowInterruption?: boolean;\n\n  containerStyle?: StyleProp<ViewStyle>;\n}\n\ninterface InternalProps {\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\n}\n\n// TODO: maybe can be better\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\n\n/**\n * GenericTouchable is not intented to be used as it is.\n * Should be treated as a source for the rest of touchables\n */\n\nexport default class GenericTouchable extends Component<\n  GenericTouchableProps & InternalProps\n> {\n  static defaultProps = {\n    delayLongPress: 600,\n    extraButtonProps: {\n      rippleColor: 'transparent',\n    },\n  };\n\n  // timeout handlers\n  pressInTimeout: Timeout;\n  pressOutTimeout: Timeout;\n  longPressTimeout: Timeout;\n\n  // This flag is required since recognition of longPress implies not-invoking onPress\n  longPressDetected = false;\n\n  pointerInside = true;\n\n  // State of touchable\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\n\n  // handlePressIn in called on first touch on traveling inside component.\n  // Handles state transition with delay.\n  handlePressIn() {\n    if (this.props.delayPressIn) {\n      this.pressInTimeout = setTimeout(() => {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n        this.pressInTimeout = null;\n      }, this.props.delayPressIn);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n    if (this.props.onLongPress) {\n      const time =\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\n    }\n  }\n  // handleMoveOutside in called on traveling outside component.\n  // Handles state transition with delay.\n  handleMoveOutside() {\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout =\n        this.pressOutTimeout ||\n        setTimeout(() => {\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n          this.pressOutTimeout = null;\n        }, this.props.delayPressOut);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n    }\n  }\n\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\n  handleGoToUndetermined() {\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout = setTimeout(() => {\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\n        }\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n        this.pressOutTimeout = null;\n      }, this.props.delayPressOut);\n    } else {\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n      }\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    }\n  }\n\n  componentDidMount() {\n    this.reset();\n  }\n  // reset timeout to prevent memory leaks.\n  reset() {\n    this.longPressDetected = false;\n    this.pointerInside = true;\n    clearTimeout(this.pressInTimeout!);\n    clearTimeout(this.pressOutTimeout!);\n    clearTimeout(this.longPressTimeout!);\n    this.pressOutTimeout = null;\n    this.longPressTimeout = null;\n    this.pressInTimeout = null;\n  }\n\n  // All states' transitions are defined here.\n  moveToState(newState: TouchableState) {\n    if (newState === this.STATE) {\n      // Ignore dummy transitions\n      return;\n    }\n    if (newState === TOUCHABLE_STATE.BEGAN) {\n      // First touch and moving inside\n      this.props.onPressIn?.();\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // Moving outside\n      this.props.onPressOut?.();\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\n      // Need to reset each time on transition to UNDETERMINED\n      this.reset();\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n        // ... and if it happens inside button.\n        this.props.onPressOut?.();\n      }\n    }\n    // Finally call lister (used by subclasses)\n    this.props.onStateChange?.(this.STATE, newState);\n    // ... and make transition.\n    this.STATE = newState;\n  }\n\n  onGestureEvent = ({\n    nativeEvent: { pointerInside },\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\n    if (this.pointerInside !== pointerInside) {\n      if (pointerInside) {\n        this.onMoveIn();\n      } else {\n        this.onMoveOut();\n      }\n    }\n    this.pointerInside = pointerInside;\n  };\n\n  onHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state } = nativeEvent;\n    if (state === State.CANCELLED || state === State.FAILED) {\n      // Need to handle case with external cancellation (e.g. by ScrollView)\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    } else if (\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\n      // And Android \"Active\" state is achieving on first move of a finger, not on press in.\n      // On iOS event on \"Began\" is not delivered.\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\n    ) {\n      // Moving inside requires\n      this.handlePressIn();\n    } else if (state === State.END) {\n      const shouldCallOnPress =\n        !this.longPressDetected &&\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\n        this.pressOutTimeout === null;\n      this.handleGoToUndetermined();\n      if (shouldCallOnPress) {\n        // Calls only inside component whether no long press was called previously\n        this.props.onPress?.();\n      }\n    }\n  };\n\n  onLongPressDetected = () => {\n    this.longPressDetected = true;\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\n    this.props.onLongPress?.();\n  };\n\n  componentWillUnmount() {\n    // to prevent memory leaks\n    this.reset();\n  }\n\n  onMoveIn() {\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // This call is not throttled with delays (like in RN's implementation).\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n  }\n\n  onMoveOut() {\n    // long press should no longer be detected\n    clearTimeout(this.longPressTimeout!);\n    this.longPressTimeout = null;\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n      this.handleMoveOutside();\n    }\n  }\n\n  render() {\n    const coreProps = {\n      accessible: this.props.accessible !== false,\n      accessibilityLabel: this.props.accessibilityLabel,\n      accessibilityHint: this.props.accessibilityHint,\n      accessibilityRole: this.props.accessibilityRole,\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\n      accessibilityState: this.props.accessibilityState,\n      nativeID: this.props.nativeID,\n      onLayout: this.props.onLayout,\n      hitSlop: this.props.hitSlop,\n    };\n\n    return (\n      <BaseButton\n        style={this.props.containerStyle}\n        onHandlerStateChange={\n          // TODO: not sure if it can be undefined instead of null\n          this.props.disabled ? undefined : this.onHandlerStateChange\n        }\n        onGestureEvent={this.onGestureEvent}\n        hitSlop={this.props.hitSlop}\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\n        disallowInterruption={this.props.disallowInterruption}\n        testID={this.props.testID}\n        {...this.props.extraButtonProps}>\n        <Animated.View {...coreProps} style={this.props.style}>\n          {this.props.children}\n        </Animated.View>\n      </BaseButton>\n    );\n  }\n}\n","import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport GenericTouchable, { GenericTouchableProps } from './GenericTouchable';\n\nconst TouchableWithoutFeedback = React.forwardRef<\n  GenericTouchable,\n  PropsWithChildren<GenericTouchableProps>\n>((props, ref) => <GenericTouchable ref={ref} {...props} />);\n\nTouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;\n\nexport default TouchableWithoutFeedback;\n","import {\n  Animated,\n  Easing,\n  StyleSheet,\n  View,\n  TouchableOpacityProps,\n} from 'react-native';\nimport GenericTouchable, {\n  TOUCHABLE_STATE,\n  GenericTouchableProps,\n} from './GenericTouchable';\nimport * as React from 'react';\nimport { Component } from 'react';\n\n/**\n * TouchableOpacity bases on timing animation which has been used in RN's core\n */\nexport default class TouchableOpacity extends Component<\n  TouchableOpacityProps & GenericTouchableProps\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.2,\n  };\n\n  // opacity is 1 one by default but could be overwritten\n  getChildStyleOpacityWithDefault = () => {\n    const childStyle = StyleSheet.flatten(this.props.style) || {};\n    return childStyle.opacity == null ? 1 : childStyle.opacity;\n  };\n\n  opacity = new Animated.Value(this.getChildStyleOpacityWithDefault());\n\n  setOpacityTo = (value: number, duration: number) => {\n    Animated.timing(this.opacity, {\n      toValue: value,\n      duration: duration,\n      easing: Easing.inOut(Easing.quad),\n      useNativeDriver: true,\n    }).start();\n  };\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.setOpacityTo(this.props.activeOpacity!, 0);\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[\n          style,\n          {\n            opacity: (this.opacity as unknown) as number, // TODO: fix this\n          },\n        ]}\n        onStateChange={this.onStateChange}>\n        {this.props.children ? this.props.children : <View />}\n      </GenericTouchable>\n    );\n  }\n}\n","import * as React from 'react';\nimport { Component } from 'react';\nimport GenericTouchable, {\n  GenericTouchableProps,\n  TOUCHABLE_STATE,\n} from './GenericTouchable';\nimport {\n  StyleSheet,\n  View,\n  TouchableHighlightProps,\n  ColorValue,\n  ViewProps,\n} from 'react-native';\n\ninterface State {\n  extraChildStyle: null | {\n    opacity?: number;\n  };\n  extraUnderlayStyle: null | {\n    backgroundColor?: ColorValue;\n  };\n}\n\n/**\n * TouchableHighlight follows RN's implementation\n */\nexport default class TouchableHighlight extends Component<\n  TouchableHighlightProps & GenericTouchableProps,\n  State\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.85,\n    delayPressOut: 100,\n    underlayColor: 'black',\n  };\n\n  constructor(props: TouchableHighlightProps & GenericTouchableProps) {\n    super(props);\n    this.state = {\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    };\n  }\n\n  // Copied from RN\n  showUnderlay = () => {\n    if (!this.hasPressHandler()) {\n      return;\n    }\n    this.setState({\n      extraChildStyle: {\n        opacity: this.props.activeOpacity,\n      },\n      extraUnderlayStyle: {\n        backgroundColor: this.props.underlayColor,\n      },\n    });\n    this.props.onShowUnderlay?.();\n  };\n\n  hasPressHandler = () =>\n    this.props.onPress ||\n    this.props.onPressIn ||\n    this.props.onPressOut ||\n    this.props.onLongPress;\n\n  hideUnderlay = () => {\n    this.setState({\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    });\n    this.props.onHideUnderlay?.();\n  };\n\n  renderChildren() {\n    if (!this.props.children) {\n      return <View />;\n    }\n\n    const child = React.Children.only(\n      this.props.children\n    ) as React.ReactElement<ViewProps>; // TODO: not sure if OK but fixes error\n    return React.cloneElement(child, {\n      style: StyleSheet.compose(child.props.style, this.state.extraChildStyle),\n    });\n  }\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.showUnderlay();\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.hideUnderlay();\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    const { extraUnderlayStyle } = this.state;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[style, extraUnderlayStyle]}\n        onStateChange={this.onStateChange}>\n        {this.renderChildren()}\n      </GenericTouchable>\n    );\n  }\n}\n","import * as React from 'react';\nimport {\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  FlatList as RNFlatList,\n  Switch as RNSwitch,\n  TextInput as RNTextInput,\n  ScrollView as RNScrollView,\n  FlatListProps,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\n\nexport const ScrollView = createNativeWrapper(RNScrollView, {\n  disallowInterruption: true,\n});\n\nexport const Switch = createNativeWrapper(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\nexport const TextInput = createNativeWrapper(RNTextInput);\nexport const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {\n  disallowInterruption: true,\n});\n// @ts-ignore -- TODO(TS) to investigate if it's needed\nDrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;\n\nexport const FlatList = React.forwardRef(\n  <ItemT extends any>(props: FlatListProps<ItemT>, ref: any) => (\n    <RNFlatList\n      ref={ref}\n      {...props}\n      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}\n    />\n  )\n);\n","// Similarily to the DrawerLayout component this deserves to be put in a\n// separate repo. Although, keeping it here for the time being will allow us\n// to move faster and fix possible issues quicker\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  I18nManager,\n  LayoutChangeEvent,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport {\n  PanGestureHandler,\n  TapGestureHandler,\n  PanGestureHandlerProps,\n  GestureEvent,\n  PanGestureHandlerEventPayload,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\ntype SwipeableExcludes = Exclude<\n  keyof PanGestureHandlerProps,\n  'onGestureEvent' | 'onHandlerStateChange'\n>;\n\ninterface SwipeableProps\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\n  enableTrackpadTwoFingerGesture?: boolean;\n  friction?: number;\n  leftThreshold?: number;\n  rightThreshold?: number;\n  overshootLeft?: boolean;\n  overshootRight?: boolean;\n  overshootFriction?: number;\n  onSwipeableLeftOpen?: () => void;\n  onSwipeableRightOpen?: () => void;\n  onSwipeableOpen?: () => void;\n  onSwipeableClose?: () => void;\n  onSwipeableLeftWillOpen?: () => void;\n  onSwipeableRightWillOpen?: () => void;\n  onSwipeableWillOpen?: () => void;\n  onSwipeableWillClose?: () => void;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, +]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderLeftActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, -]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderRightActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  useNativeAnimations?: boolean;\n  animationOptions?: Record<string, unknown>;\n  containerStyle?: StyleProp<ViewStyle>;\n  childrenContainerStyle?: StyleProp<ViewStyle>;\n}\n\ntype SwipeableState = {\n  dragX: Animated.Value;\n  rowTranslation: Animated.Value;\n  rowState: number;\n  leftWidth?: number;\n  rightOffset?: number;\n  rowWidth?: number;\n};\n\nexport default class Swipeable extends Component<\n  SwipeableProps,\n  SwipeableState\n> {\n  static defaultProps = {\n    friction: 1,\n    overshootFriction: 1,\n    useNativeAnimations: true,\n  };\n\n  constructor(props: SwipeableProps) {\n    super(props);\n    const dragX = new Animated.Value(0);\n    this.state = {\n      dragX,\n      rowTranslation: new Animated.Value(0),\n      rowState: 0,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      rowWidth: undefined,\n    };\n    this.updateAnimatedEvent(props, this.state);\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragX } }],\n      { useNativeDriver: props.useNativeAnimations! }\n    );\n  }\n\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\n    if (\n      this.props.friction !== props.friction ||\n      this.props.overshootLeft !== props.overshootLeft ||\n      this.props.overshootRight !== props.overshootRight ||\n      this.props.overshootFriction !== props.overshootFriction ||\n      this.state.leftWidth !== state.leftWidth ||\n      this.state.rightOffset !== state.rightOffset ||\n      this.state.rowWidth !== state.rowWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private transX?: Animated.AnimatedInterpolation;\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\n\n  private updateAnimatedEvent = (\n    props: SwipeableProps,\n    state: SwipeableState\n  ) => {\n    const { friction, overshootFriction } = props;\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\n    const { rightOffset = rowWidth } = state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n\n    const {\n      overshootLeft = leftWidth > 0,\n      overshootRight = rightWidth > 0,\n    } = props;\n\n    const transX = Animated.add(\n      rowTranslation,\n      dragX.interpolate({\n        inputRange: [0, friction!],\n        outputRange: [0, 1],\n      })\n    ).interpolate({\n      inputRange: [\n        -rightWidth - (overshootRight ? 1 : overshootFriction!),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft ? 1 : overshootFriction!),\n      ],\n      outputRange: [\n        -rightWidth - (overshootRight || overshootFriction! > 1 ? 1 : 0),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft || overshootFriction! > 1 ? 1 : 0),\n      ],\n    });\n    this.transX = transX;\n    this.showLeftAction =\n      leftWidth > 0\n        ? transX.interpolate({\n            inputRange: [-1, 0, leftWidth],\n            outputRange: [0, 0, 1],\n          })\n        : new Animated.Value(0);\n    this.leftActionTranslate = this.showLeftAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n    this.showRightAction =\n      rightWidth > 0\n        ? transX.interpolate({\n            inputRange: [-rightWidth, 0, 1],\n            outputRange: [1, 0, 0],\n          })\n        : new Animated.Value(0);\n    this.rightActionTranslate = this.showRightAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.close();\n    }\n  };\n\n  private onHandlerStateChange = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease(ev);\n    }\n  };\n\n  private handleRelease = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    const {\n      friction,\n      leftThreshold = leftWidth / 2,\n      rightThreshold = rightWidth / 2,\n    } = this.props;\n\n    const startOffsetX = this.currentOffset() + dragX / friction!;\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\n\n    let toValue = 0;\n    if (rowState === 0) {\n      if (translationX > leftThreshold) {\n        toValue = leftWidth;\n      } else if (translationX < -rightThreshold) {\n        toValue = -rightWidth;\n      }\n    } else if (rowState === 1) {\n      // swiped to left\n      if (translationX > -leftThreshold) {\n        toValue = leftWidth;\n      }\n    } else {\n      // swiped to right\n      if (translationX < rightThreshold) {\n        toValue = -rightWidth;\n      }\n    }\n\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\n  };\n\n  private animateRow = (\n    fromValue: number,\n    toValue: number,\n    velocityX?:\n      | number\n      | {\n          x: number;\n          y: number;\n        }\n  ) => {\n    const { dragX, rowTranslation } = this.state;\n    dragX.setValue(0);\n    rowTranslation.setValue(fromValue);\n\n    this.setState({ rowState: Math.sign(toValue) });\n    Animated.spring(rowTranslation, {\n      restSpeedThreshold: 1.7,\n      restDisplacementThreshold: 0.4,\n      velocity: velocityX,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      ...this.props.animationOptions,\n    }).start(({ finished }) => {\n      if (finished) {\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n          this.props.onSwipeableLeftOpen();\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\n          this.props.onSwipeableRightOpen();\n        }\n\n        if (toValue === 0) {\n          this.props.onSwipeableClose?.();\n        } else {\n          this.props.onSwipeableOpen?.();\n        }\n      }\n    });\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\n      this.props.onSwipeableLeftWillOpen();\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\n      this.props.onSwipeableRightWillOpen();\n    }\n\n    if (toValue === 0) {\n      this.props.onSwipeableWillClose?.();\n    } else {\n      this.props.onSwipeableWillOpen?.();\n    }\n  };\n\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ rowWidth: nativeEvent.layout.width });\n  };\n\n  private currentOffset = () => {\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    if (rowState === 1) {\n      return leftWidth;\n    } else if (rowState === -1) {\n      return -rightWidth;\n    }\n    return 0;\n  };\n\n  close = () => {\n    this.animateRow(this.currentOffset(), 0);\n  };\n\n  openLeft = () => {\n    const { leftWidth = 0 } = this.state;\n    this.animateRow(this.currentOffset(), leftWidth);\n  };\n\n  openRight = () => {\n    const { rowWidth = 0 } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    this.animateRow(this.currentOffset(), -rightWidth);\n  };\n\n  render() {\n    const { rowState } = this.state;\n    const { children, renderLeftActions, renderRightActions } = this.props;\n\n    const left = renderLeftActions && (\n      <Animated.View\n        style={[\n          styles.leftActions,\n          // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason\n          { transform: [{ translateX: this.leftActionTranslate! }] },\n        ]}>\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ leftWidth: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    const right = renderRightActions && (\n      <Animated.View\n        style={[\n          styles.rightActions,\n          { transform: [{ translateX: this.rightActionTranslate! }] },\n        ]}>\n        {renderRightActions(this.showRightAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ rightOffset: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    return (\n      <PanGestureHandler\n        activeOffsetX={[-10, 10]}\n        {...this.props}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}>\n        <Animated.View\n          onLayout={this.onRowLayout}\n          style={[styles.container, this.props.containerStyle]}>\n          {left}\n          {right}\n          <TapGestureHandler\n            enabled={rowState !== 0}\n            onHandlerStateChange={this.onTapHandlerStateChange}>\n            <Animated.View\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\n              style={[\n                {\n                  transform: [{ translateX: this.transX! }],\n                },\n                this.props.childrenContainerStyle,\n              ]}>\n              {children}\n            </Animated.View>\n          </TapGestureHandler>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden',\n  },\n  leftActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\n  },\n  rightActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\n  },\n});\n","// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n  StatusBarAnimation,\n  StyleProp,\n  ViewStyle,\n  LayoutChangeEvent,\n  NativeSyntheticEvent,\n} from 'react-native';\n\nimport {\n  GestureEvent,\n  PanGestureHandler,\n  PanGestureHandlerEventPayload,\n  TapGestureHandler,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE: DrawerState = 'Idle';\nconst DRAGGING: DrawerState = 'Dragging';\nconst SETTLING: DrawerState = 'Settling';\n\nexport type DrawerPosition = 'left' | 'right';\n\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\n\nexport type DrawerType = 'front' | 'back' | 'slide';\n\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\n\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\n\nexport interface DrawerLayoutProps {\n  renderNavigationView: (\n    progressAnimatedValue: Animated.Value\n  ) => React.ReactNode;\n  drawerPosition?: DrawerPosition;\n  drawerWidth?: number;\n  drawerBackgroundColor?: string;\n  drawerLockMode?: DrawerLockMode;\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\n  onDrawerClose?: () => void;\n  onDrawerOpen?: () => void;\n  onDrawerStateChanged?: (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => void;\n  useNativeAnimations?: boolean;\n\n  drawerType?: DrawerType;\n  edgeWidth?: number;\n  minSwipeDistance?: number;\n  hideStatusBar?: boolean;\n  statusBarAnimation?: StatusBarAnimation;\n  overlayColor?: string;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  drawerContainerStyle?: StyleProp<ViewStyle>;\n  enableTrackpadTwoFingerGesture?: boolean;\n  onDrawerSlide?: (position: number) => void;\n  onGestureRef?: (ref: PanGestureHandler) => void;\n}\n\nexport type DrawerLayoutState = {\n  dragX: Animated.Value;\n  touchX: Animated.Value;\n  drawerTranslation: Animated.Value;\n  containerWidth: number;\n};\n\nexport type DrawerMovementOption = {\n  velocity?: number;\n  speed?: number;\n};\nexport default class DrawerLayout extends Component<\n  DrawerLayoutProps,\n  DrawerLayoutState\n> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\n    drawerLockMode: 'unlocked',\n    enableTrackpadTwoFingerGesture: false,\n  };\n\n  constructor(props: DrawerLayoutProps) {\n    super(props);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this.updateAnimatedEvent(props, this.state);\n  }\n\n  UNSAFE_componentWillUpdate(\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private openValue?: Animated.AnimatedInterpolation;\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private accessibilityIsModalView = React.createRef<View>();\n  private pointerEventsView = React.createRef<View>();\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\n  private drawerShown = false;\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n\n  private updateAnimatedEvent = (\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(\n        new Animated.Value(-1),\n        dragXValue\n      ) as Animated.Value; // TODO(TS): (for all \"as\" in this file) make sure we can map this\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(\n        dragX,\n        dragOffsetFromOnStartPosition\n      ) as Animated.Value; // TODO: as above\n    }\n\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\n      inputRange: [0, drawerWidth!],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n\n    const gestureOptions: {\n      useNativeDriver: boolean;\n      // TODO: make sure it is correct\n      listener?: (\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\n      ) => void;\n    } = {\n      useNativeDriver: props.useNativeAnimations!,\n    };\n\n    if (this.props.onDrawerSlide) {\n      gestureOptions.listener = (ev) => {\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\n        const position = translationX / this.state.containerWidth;\n\n        this.props.onDrawerSlide?.(position);\n      };\n    }\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      gestureOptions\n    );\n  };\n\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  private emitStateChanged = (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => {\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\n  };\n\n  private openingHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease({ nativeEvent });\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this.emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (\n      this.drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  private handleRelease = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\n\n    if (shouldOpen) {\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\n    } else {\n      this.animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  private updateShowing = (showing: boolean) => {\n    this.drawerShown = showing;\n    this.accessibilityIsModalView.current?.setNativeProps({\n      accessibilityViewIsModal: showing,\n    });\n    this.pointerEventsView.current?.setNativeProps({\n      pointerEvents: showing ? 'auto' : 'none',\n    });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    // @ts-ignore internal API, maybe could be fixed in handler types\n    this.panGestureHandler.current?.setNativeProps({\n      hitSlop,\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\n    });\n  };\n\n  private animateDrawer = (\n    fromValue: number | null | undefined,\n    toValue: number,\n    velocity: number,\n    speed?: number\n  ) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue != null) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this.updateShowing(willShow);\n    this.emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      speed: speed ?? undefined,\n    }).start(({ finished }) => {\n      if (finished) {\n        this.emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen?.();\n        } else {\n          this.props.onDrawerClose?.();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOption = {}) => {\n    this.animateDrawer(\n      // TODO: decide if it should be null or undefined is the proper value\n      undefined,\n      this.props.drawerWidth!,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOption = {}) => {\n    // TODO: decide if it should be null or undefined is the proper value\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  private renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this.openValue, 'should be set');\n    const overlayOpacity = this.openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\n          ref={this.pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  private renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this.openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles: {\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\n      flexDirection: 'row-reverse' | 'row';\n    } = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}\n          importantForAccessibility={\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\n          }>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this.openValue)\n            : this.props.children}\n          {this.renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this.accessibilityIsModalView}\n          accessibilityViewIsModal={this.drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  private setPanGestureRef = (ref: PanGestureHandler) => {\n    // TODO(TS): make sure it is OK\n    // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\n    (this\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\n    this.props.onGestureRef?.(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        // @ts-ignore could be fixed in handler types\n        ref={this.setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.openingHandlerStateChange}\n        enableTrackpadTwoFingerGesture={\n          this.props.enableTrackpadTwoFingerGesture\n        }\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this.renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","\"use strict\";\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar aStackPool = [];\nvar bStackPool = [];\n/**\n * Checks if two values are equal. Values may be primitives, arrays, or objects.\n * Returns true if both arguments have the same keys and values.\n *\n * @see http://underscorejs.org\n * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n * @license MIT\n */\n\nfunction areEqual(a, b) {\n  var aStack = aStackPool.length ? aStackPool.pop() : [];\n  var bStack = bStackPool.length ? bStackPool.pop() : [];\n  var result = eq(a, b, aStack, bStack);\n  aStack.length = 0;\n  bStack.length = 0;\n  aStackPool.push(aStack);\n  bStackPool.push(bStack);\n  return result;\n}\n\nfunction eq(a, b, aStack, bStack) {\n  if (a === b) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    return a !== 0 || 1 / a == 1 / b;\n  }\n\n  if (a == null || b == null) {\n    // a or b can be `null` or `undefined`\n    return false;\n  }\n\n  if (typeof a != 'object' || typeof b != 'object') {\n    return false;\n  }\n\n  var objToStr = Object.prototype.toString;\n  var className = objToStr.call(a);\n\n  if (className != objToStr.call(b)) {\n    return false;\n  }\n\n  switch (className) {\n    case '[object String]':\n      return a == String(b);\n\n    case '[object Number]':\n      return isNaN(a) || isNaN(b) ? false : a == Number(b);\n\n    case '[object Date]':\n    case '[object Boolean]':\n      return +a == +b;\n\n    case '[object RegExp]':\n      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n  } // Assume equality for cyclic structures.\n\n\n  var length = aStack.length;\n\n  while (length--) {\n    if (aStack[length] == a) {\n      return bStack[length] == b;\n    }\n  }\n\n  aStack.push(a);\n  bStack.push(b);\n  var size = 0; // Recursively compare objects and arrays.\n\n  if (className === '[object Array]') {\n    size = a.length;\n\n    if (size !== b.length) {\n      return false;\n    } // Deep compare the contents, ignoring non-numeric properties.\n\n\n    while (size--) {\n      if (!eq(a[size], b[size], aStack, bStack)) {\n        return false;\n      }\n    }\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    if (a.hasOwnProperty('valueOf') && b.hasOwnProperty('valueOf')) {\n      return a.valueOf() == b.valueOf();\n    }\n\n    var keys = Object.keys(a);\n\n    if (keys.length != Object.keys(b).length) {\n      return false;\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      if (!eq(a[keys[i]], b[keys[i]], aStack, bStack)) {\n        return false;\n      }\n    }\n  }\n\n  aStack.pop();\n  bStack.pop();\n  return true;\n}\n\nmodule.exports = areEqual;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nlet assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    let output = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      const source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (const nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nexport default assign;","/* eslint-disable no-new-func, no-nested-ternary */\n\nlet win;\n\nif (typeof window === \"undefined\") {\n\t// window is undefined in node.js\n\twin = {};\n} else {\n\twin = window;\n}\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport {win as window};\n","\nconst VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nconst TEST_ELEMENT = typeof document === \"undefined\" ? {style: {}} : document.createElement('div');\n\nconst TYPE_FUNCTION = 'function';\n\nconst { round, abs } = Math;\nconst { now } = Date;\n\nexport {\n    VENDOR_PREFIXES,\n    TEST_ELEMENT,\n    TYPE_FUNCTION,\n    round,\n    abs,\n    now\n};\n","import { VENDOR_PREFIXES } from './utils-consts';\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nexport default function prefixed(obj, property) {\n  let prefix;\n  let prop;\n  let camelProp = property[0].toUpperCase() + property.slice(1);\n\n  let i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = (prefix) ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n","import prefixed from '../utils/prefixed';\nimport { TEST_ELEMENT } from '../utils/utils-consts';\nimport {window} from '../browser';\n\nexport const PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nexport const NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\nexport default function getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  let touchMap = {};\n  let cssSupports = window.CSS && window.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach((val) => {\n\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n","import getTouchActionProps from './get-touchaction-props';\n\n\n\n// magical touchAction value\nconst TOUCH_ACTION_COMPUTE = 'compute';\nconst TOUCH_ACTION_AUTO = 'auto';\nconst TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nconst TOUCH_ACTION_NONE = 'none';\nconst TOUCH_ACTION_PAN_X = 'pan-x';\nconst TOUCH_ACTION_PAN_Y = 'pan-y';\nconst TOUCH_ACTION_MAP = getTouchActionProps();\n\nexport {\n  TOUCH_ACTION_AUTO,\n  TOUCH_ACTION_COMPUTE,\n  TOUCH_ACTION_MANIPULATION,\n  TOUCH_ACTION_NONE,\n  TOUCH_ACTION_PAN_X,\n  TOUCH_ACTION_PAN_Y,\n  TOUCH_ACTION_MAP\n};\n","import prefixed from '../utils/prefixed';\nimport {window} from \"../browser\";\n\nconst MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nconst SUPPORT_TOUCH = ('ontouchstart' in window);\nconst SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nconst SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nconst INPUT_TYPE_TOUCH = 'touch';\nconst INPUT_TYPE_PEN = 'pen';\nconst INPUT_TYPE_MOUSE = 'mouse';\nconst INPUT_TYPE_KINECT = 'kinect';\n\nconst COMPUTE_INTERVAL = 25;\n\nconst INPUT_START = 1;\nconst INPUT_MOVE = 2;\nconst INPUT_END = 4;\nconst INPUT_CANCEL = 8;\n\nconst DIRECTION_NONE = 1;\nconst DIRECTION_LEFT = 2;\nconst DIRECTION_RIGHT = 4;\nconst DIRECTION_UP = 8;\nconst DIRECTION_DOWN = 16;\n\nconst DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nconst DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nconst DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nconst PROPS_XY = ['x', 'y'];\nconst PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\nexport {\n    MOBILE_REGEX,\n    SUPPORT_ONLY_TOUCH,\n    SUPPORT_POINTER_EVENTS,\n    SUPPORT_TOUCH,\n    INPUT_TYPE_KINECT,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_TOUCH,\n    COMPUTE_INTERVAL,\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    DIRECTION_NONE,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_ALL,\n    PROPS_XY,\n    PROPS_CLIENT_XY\n};\n","/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nexport default function each(obj, iterator, context) {\n  let i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n","import { TYPE_FUNCTION } from './utils-consts';\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nexport default function boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n","/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nexport default function inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n","import {\n    TOUCH_ACTION_COMPUTE,\n    TOUCH_ACTION_MAP,\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y\n} from './touchaction-Consts';\nimport {\n  NATIVE_TOUCH_ACTION,\n  PREFIXED_TOUCH_ACTION,\n} from \"./get-touchaction-props\";\nimport {\n    DIRECTION_VERTICAL,\n    DIRECTION_HORIZONTAL\n} from '../inputjs/input-consts';\nimport each from '../utils/each';\nimport boolOrFn from '../utils/bool-or-fn';\nimport inStr from '../utils/in-str';\nimport cleanTouchActions from './clean-touch-actions';\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nexport default class TouchAction {\n  constructor(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n  set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  }\n\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n  update() {\n    this.set(this.manager.options.touchAction);\n  }\n\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n  compute() {\n    let actions = [];\n    each(this.manager.recognizers, (recognizer) => {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  }\n\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n  preventDefaults(input) {\n    let { srcEvent } = input;\n    let direction = input.offsetDirection;\n\n    // if the touch action did prevented once this session\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    let { actions } = this;\n    let hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      let isTapPointer = input.pointers.length === 1;\n      let isTapMovement = input.distance < 2;\n      let isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone ||\n        (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n        (hasPanX && direction & DIRECTION_VERTICAL)) {\n      return this.preventSrc(srcEvent);\n    }\n  }\n\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n  preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  }\n}\n","import inStr from '../utils/in-str';\nimport {\n    TOUCH_ACTION_NONE,\n    TOUCH_ACTION_PAN_X,\n    TOUCH_ACTION_PAN_Y,\n    TOUCH_ACTION_MANIPULATION,\n    TOUCH_ACTION_AUTO\n} from './touchaction-Consts';\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nexport default function cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n  // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  // pan-x OR pan-y\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  }\n\n  // manipulation\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n","/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nexport default function hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n","import { round } from '../utils/utils-consts';\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nexport default function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  let x = 0;\n  let y = 0;\n  let i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n","import { now,round } from '../utils/utils-consts';\nimport getCenter from './get-center';\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nexport default function simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  let pointers = [];\n  let i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nexport default function getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n\n  return Math.sqrt((x * x) + (y * y));\n}\n","import { PROPS_XY } from './input-consts';\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nexport default function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  let x = p2[props[0]] - p1[props[0]];\n  let y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n","import { abs } from '../utils/utils-consts';\nimport { DIRECTION_NONE,DIRECTION_LEFT,DIRECTION_RIGHT,DIRECTION_UP,DIRECTION_DOWN } from './input-consts';\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nexport default function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n","/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nexport default function getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n","import { now } from '../utils/utils-consts';\nimport { abs } from '../utils/utils-consts';\nimport hasParent from '../utils/has-parent';\nimport simpleCloneInputData from './simple-clone-input-data';\nimport getCenter from './get-center';\nimport getDistance from './get-distance';\nimport getAngle from './get-angle';\nimport getDirection from './get-direction';\nimport computeDeltaXY from './compute-delta-xy';\nimport getVelocity from './get-velocity';\nimport getScale from './get-scale';\nimport getRotation from './get-rotation';\nimport computeIntervalInputData from './compute-interval-input-data';\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nexport default function computeInputData(manager, input) {\n  let { session } = manager;\n  let { pointers } = input;\n  let { length:pointersLength } = pointers;\n\n  // store the first input to calculate the distance and direction\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  }\n\n  // to compute scale and rotation we need to store the multiple touches\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  let { firstInput, firstMultiple } = session;\n  let offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n  let center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n  let overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;\n\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n  input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >\n  session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);\n\n  computeIntervalInputData(session, input);\n\n  // find the correct target\n  let target = manager.element;\n  const srcEvent = input.srcEvent;\n  let srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n","import { INPUT_START, INPUT_END } from './input-consts';\n\nexport default function computeDeltaXY(session, input) {\n  let { center } = input;\n  // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n  let offset = session.offsetDelta || {};\n  let prevDelta = session.prevDelta || {};\n  let prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n","import { PROPS_CLIENT_XY } from './input-consts';\nimport getDistance from './get-distance';\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nexport default function getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n","import getAngle from './get-angle';\nimport { PROPS_CLIENT_XY } from './input-consts';\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nexport default function getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n","import { INPUT_CANCEL,COMPUTE_INTERVAL } from './input-consts';\nimport { abs } from '../utils/utils-consts';\nimport getVelocity from './get-velocity';\nimport getDirection from './get-direction';\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nexport default function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n","import { INPUT_START,INPUT_END,INPUT_CANCEL } from './input-consts';\nimport computeInputData from './compute-input-data';\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nexport default function inputHandler(manager, eventType, input) {\n  let pointersLen = input.pointers.length;\n  let changedPointersLen = input.changedPointers.length;\n  let isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n  let isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  }\n\n  // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n  input.eventType = eventType;\n\n  // compute scale, rotation etc\n  computeInputData(manager, input);\n\n  // emit secret event\n  manager.emit('hammer.input', input);\n\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n","/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\n\nexport default function splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function addEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.addEventListener(type, handler, false);\n  });\n}\n","import each from './each';\nimport splitStr from './split-str';\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nexport default function removeEventListeners(target, types, handler) {\n  each(splitStr(types), (type) => {\n    target.removeEventListener(type, handler, false);\n  });\n}\n","/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nexport default function getWindowForElement(element) {\n  let doc = element.ownerDocument || element;\n  return (doc.defaultView || doc.parentWindow || window);\n}\n","import boolOrFn from '../utils/bool-or-fn';\nimport addEventListeners from '../utils/add-event-listeners';\nimport removeEventListeners from '../utils/remove-event-listeners';\nimport getWindowForElement from '../utils/get-window-for-element';\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nexport default class Input {\n  constructor(manager, callback) {\n    let self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n  handler() { }\n\n  /**\n   * @private\n   * bind the events\n   */\n  init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n\n  /**\n   * @private\n   * unbind the events\n   */\n  destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  }\n}\n","/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nexport default function inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    let i = 0;\n    while (i < src.length) {\n      if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {// do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\n","import {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_MOVE,\n    INPUT_TYPE_TOUCH,\n    INPUT_TYPE_MOUSE,\n    INPUT_TYPE_PEN,\n    INPUT_TYPE_KINECT\n} from '../inputjs/input-consts';\nimport {window} from \"../browser\";\nimport Input from '../inputjs/input-constructor';\nimport inArray from '../utils/in-array';\n\nconst POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nconst IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nlet POINTER_ELEMENT_EVENTS = 'pointerdown';\nlet POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent && !window.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\nexport default class PointerEventInput extends Input {\n  constructor() {\n    var proto = PointerEventInput.prototype;\n\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    super(...arguments);\n    this.store = (this.manager.session.pointerEvents = []);\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let { store } = this;\n    let removePointer = false;\n\n    let eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    let eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    let pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n    let isTouch = (pointerType === INPUT_TYPE_TOUCH);\n\n    // get index of the event in the store\n    let storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n    // start and mouse must be down\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    }\n\n    // it not found, so the pointer hasn't been down (so it's probably a hover)\n    if (storeIndex < 0) {\n      return;\n    }\n\n    // update the event in the store\n    store[storeIndex] = ev;\n\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  }\n}\n","/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nexport default function toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n","import inArray from './in-array';\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nexport default function uniqueArray(src, key, sort) {\n  let results = [];\n  let values = [];\n  let i = 0;\n\n  while (i < src.length) {\n    let val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort((a, b) => {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n","import {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport hasParent from '../utils/has-parent';\nimport uniqueArray from '../utils/unique-array';\n\nconst TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nexport default class TouchInput extends Input {\n  constructor() {\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    super(...arguments);\n    this.targetIds = {};\n    // this.evTarget = TOUCH_TARGET_EVENTS;\n  }\n  handler(ev) {\n    let type = TOUCH_INPUT_MAP[ev.type];\n    let touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds } = this;\n\n  // when there is only one touch, the process can be simplified\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  let i;\n  let targetTouches;\n  let changedTouches = toArray(ev.changedTouches);\n  let changedTargetTouches = [];\n  let { target } = this;\n\n  // get target touches from touches\n  targetTouches = allTouches.filter((touch) => {\n    return hasParent(touch.target, target);\n  });\n\n  // collect touches\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  }\n\n  // filter changed touches to only contain touches that exist in the collected target ids\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    }\n\n    // cleanup removed touches\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n    changedTargetTouches\n  ];\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_TYPE_MOUSE\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\n\nconst MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\n\nconst MOUSE_ELEMENT_EVENTS = 'mousedown';\nconst MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\nexport default class MouseInput extends Input {\n  constructor() {\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.pressed = false; // mousedown state\n  }\n\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n  handler(ev) {\n    let eventType = MOUSE_INPUT_MAP[ev.type];\n\n    // on start we want to have the left mouse button down\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    }\n\n    // mouse must be down\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  }\n}\n","import Input from \"../inputjs/input-constructor\";\nimport TouchInput from \"./touch\";\nimport MouseInput from \"./mouse\";\nimport {\n\tINPUT_START,\n\tINPUT_END,\n\tINPUT_CANCEL,\n\tINPUT_TYPE_TOUCH,\n\tINPUT_TYPE_MOUSE,\n} from \"../inputjs/input-consts\";\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nconst DEDUP_TIMEOUT = 2500;\nconst DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n\tconst { changedPointers: [touch] } = eventData;\n\n\tif (touch.identifier === this.primaryTouch) {\n\t\tconst lastTouch = { x: touch.clientX, y: touch.clientY };\n\t\tconst lts = this.lastTouches;\n\n\t\tthis.lastTouches.push(lastTouch);\n\n\n\t\tconst removeLastTouch = function() {\n\t\t\tconst i = lts.indexOf(lastTouch);\n\n\t\t\tif (i > -1) {\n\t\t\t\tlts.splice(i, 1);\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(removeLastTouch, DEDUP_TIMEOUT);\n\t}\n}\n\n\nfunction recordTouches(eventType, eventData) {\n\tif (eventType & INPUT_START) {\n\t\tthis.primaryTouch = eventData.changedPointers[0].identifier;\n\t\tsetLastTouch.call(this, eventData);\n\t} else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t\tsetLastTouch.call(this, eventData);\n\t}\n}\nfunction isSyntheticEvent(eventData) {\n\tconst x = eventData.srcEvent.clientX;\n\tconst y = eventData.srcEvent.clientY;\n\n\tfor (let i = 0; i < this.lastTouches.length; i++) {\n\t\tconst t = this.lastTouches[i];\n\t\tconst dx = Math.abs(x - t.x);\n\t\tconst dy = Math.abs(y - t.y);\n\n\t\tif (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport default class TouchMouseInput extends Input {\n\tconstructor(manager, callback) {\n\t\tsuper(manager, callback);\n\n\t\tthis.touch = new TouchInput(this.manager, this.handler);\n\t\tthis.mouse = new MouseInput(this.manager, this.handler);\n\t\tthis.primaryTouch = null;\n\t\tthis.lastTouches = [];\n\t}\n\n\t/**\n\t * @private\n\t * handle mouse and touch events\n\t * @param {Hammer} manager\n\t * @param {String} inputEvent\n\t * @param {Object} inputData\n\t */\n\thandler = (manager, inputEvent, inputData) => {\n\t\tconst isTouch = (inputData.pointerType === INPUT_TYPE_TOUCH);\n\t\tconst isMouse = (inputData.pointerType === INPUT_TYPE_MOUSE);\n\n\t\tif (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n\t\t\treturn;\n\t\t}\n\n\t\t// when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\t\tif (isTouch) {\n\t\t\trecordTouches.call(this, inputEvent, inputData);\n\t\t} else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.callback(manager, inputEvent, inputData);\n\t}\n\n\t/**\n\t * @private\n\t * remove the event listeners\n\t */\n\tdestroy() {\n\t\tthis.touch.destroy();\n\t\tthis.mouse.destroy();\n\t}\n}\n","import each from './each';\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nexport default function invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\n","const STATE_POSSIBLE = 1;\nconst STATE_BEGAN = 2;\nconst STATE_CHANGED = 4;\nconst STATE_ENDED = 8;\nconst STATE_RECOGNIZED = STATE_ENDED;\nconst STATE_CANCELLED = 16;\nconst STATE_FAILED = 32;\n\nexport {\n    STATE_POSSIBLE,\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_ENDED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_FAILED\n};\n","/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nlet _uniqueId = 1;\nexport default function uniqueId() {\n  return _uniqueId++;\n}\n","/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nexport default function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  let { manager } = recognizer;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n","import {\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_CHANGED,\n    STATE_BEGAN\n} from './recognizer-consts';\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\nexport default function stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n","import {\n    STATE_POSSIBLE,\n    STATE_ENDED,\n    STATE_FAILED,\n    STATE_RECOGNIZED,\n    STATE_CANCELLED,\n    STATE_BEGAN,\n    STATE_CHANGED\n} from './recognizer-consts';\nimport assign from '../utils/assign';\nimport uniqueId from '../utils/unique-id';\nimport invokeArrayArg from '../utils/invoke-array-arg';\nimport inArray from '../utils/in-array';\nimport boolOrFn from '../utils/bool-or-fn';\nimport getRecognizerByNameIfManager from './get-recognizer-by-name-if-manager';\nimport stateStr from './state-str';\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nexport default class Recognizer {\n  constructor(options = {}) {\n    this.options = {\n      enable: true,\n      ...options,\n    };\n\n    this.id = uniqueId();\n\n    this.manager = null;\n\n    // default is enable true\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n  set(options) {\n    assign(this.options, options);\n\n    // also update the touchAction, in case something changed about the directions/enabled state\n    this.manager && this.manager.touchAction.update();\n    return this;\n  }\n\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    let { simultaneous } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  }\n\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    let { requireFail } = this;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n  dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    let index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  }\n\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n  hasRequireFailures() {\n    return this.requireFail.length > 0;\n  }\n\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n  canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  }\n\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n  emit(input) {\n    let self = this;\n    let { state } = this;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    }\n\n    // 'panstart' and 'panmove'\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    }\n\n    // panend and pancancel\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  }\n\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n  tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    }\n    // it's failing anyway\n    this.state = STATE_FAILED;\n  }\n\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n  canEmit() {\n    let i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n  recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    let inputDataClone = assign({}, inputData);\n\n    // is is enabled and allow recognizing?\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    }\n\n    // reset when we've reached the end\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone);\n\n    // the recognizer has recognized a gesture\n    // so trigger an event\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  }\n\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n  process(inputData) { }\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n  getTouchAction() { }\n\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n  reset() { }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport { TOUCH_ACTION_MANIPULATION } from '../touchactionjs/touchaction-Consts';\nimport {INPUT_START,INPUT_END } from '../inputjs/input-consts';\nimport {\n    STATE_RECOGNIZED,\n    STATE_BEGAN,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport getDistance from '../inputjs/get-distance';\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nexport default class TapRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300, // max time between the multi-tap taps\n      time: 250, // max time of the pointer to be down (like finger on the screen)\n      threshold: 9, // a minimal movement is ok, but keep it low\n      posThreshold: 10, // a multi-tap can be a bit off the initial position\n      ...options,\n    });\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  }\n\n  process(input) {\n    let { options } = this;\n\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTouchTime = input.deltaTime < options.time;\n\n    this.reset();\n\n    if ((input.eventType & INPUT_START) && (this.count === 0)) {\n      return this.failTimeout();\n    }\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      let validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n      let validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input;\n\n      // if tap count matches we have recognized it,\n      // else it has began recognizing...\n      let tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(() => {\n            this.state = STATE_RECOGNIZED;\n            this.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  }\n\n  failTimeout() {\n    this._timer = setTimeout(() => {\n      this.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_BEGAN,\n    STATE_CHANGED,\n    STATE_CANCELLED,\n    STATE_ENDED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport {\n    INPUT_CANCEL,\n    INPUT_END\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nexport default class AttrRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n  attrTest(input) {\n    let optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  }\n\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n  process(input) {\n    let { state } = this;\n    let { eventType } = input;\n\n    let isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    let isValid = this.attrTest(input);\n\n    // on cancel input and we've recognized before, return STATE_CANCELLED\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  }\n}\n","import {\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT,\n    DIRECTION_UP,\n    DIRECTION_DOWN\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\nexport default function directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n","import  AttrRecognizer from './attribute';\nimport {\n    DIRECTION_ALL,\n    DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL,\n    DIRECTION_NONE,\n    DIRECTION_UP,\n    DIRECTION_DOWN,\n    DIRECTION_LEFT,\n    DIRECTION_RIGHT\n} from '../inputjs/input-consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\nimport { TOUCH_ACTION_PAN_X,TOUCH_ACTION_PAN_Y } from '../touchactionjs/touchaction-Consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PanRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL,\n      ...options,\n    });\n    this.pX = null;\n    this.pY = null;\n  }\n\n  getTouchAction() {\n    let { options:{ direction } } = this;\n    let actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  }\n\n  directionTest(input) {\n    let { options } = this;\n    let hasMoved = true;\n    let { distance } = input;\n    let { direction } = input;\n    let x = input.deltaX;\n    let y = input.deltaY;\n\n    // lock to axis?\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  }\n\n  attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && // replace with a super call\n        (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n  }\n\n  emit(input) {\n\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n\n    let direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from '../recognizers/attribute';\nimport { abs } from '../utils/utils-consts';\nimport { DIRECTION_HORIZONTAL,DIRECTION_VERTICAL } from '../inputjs/input-consts';\nimport PanRecognizer from './pan';\nimport { INPUT_END } from '../inputjs/input-consts';\nimport directionStr from '../recognizerjs/direction-str';\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class SwipeRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  }\n\n  attrTest(input) {\n    let { direction } = this.options;\n    let velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return super.attrTest(input) &&\n        direction & input.offsetDirection &&\n        input.distance > this.options.threshold &&\n        input.maxPointers === this.options.pointers &&\n        abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  }\n\n  emit(input) {\n    let direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class PinchRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n\n  emit(input) {\n    if (input.scale !== 1) {\n      let inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    super.emit(input);\n  }\n}\n","import AttrRecognizer from './attribute';\nimport { TOUCH_ACTION_NONE } from '../touchactionjs/touchaction-Consts';\nimport { STATE_BEGAN } from '../recognizerjs/recognizer-consts';\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nexport default class RotateRecognizer extends AttrRecognizer {\n  constructor(options = {}) {\n    super( {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2,\n      ...options,\n    });\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  }\n\n  attrTest(input) {\n    return super.attrTest(input) &&\n        (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  }\n}","import Recognizer from '../recognizerjs/recognizer-constructor';\nimport {\n    STATE_RECOGNIZED,\n    STATE_FAILED\n} from '../recognizerjs/recognizer-consts';\nimport { now } from '../utils/utils-consts';\nimport { TOUCH_ACTION_AUTO } from '../touchactionjs/touchaction-Consts';\nimport {\n    INPUT_START,\n    INPUT_END,\n    INPUT_CANCEL\n} from '../inputjs/input-consts';\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nexport default class PressRecognizer extends Recognizer {\n  constructor(options = {}) {\n    super({\n      event: 'press',\n      pointers: 1,\n      time: 251, // minimal time of the pointer to be pressed\n      threshold: 9, // a minimal movement is ok, but keep it low\n      ...options,\n    });\n    this._timer = null;\n    this._input = null;\n  }\n\n  getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  }\n\n  process(input) {\n    let { options } = this;\n    let validPointers = input.pointers.length === options.pointers;\n    let validMovement = input.distance < options.threshold;\n    let validTime = input.deltaTime > options.time;\n\n    this._input = input;\n\n    // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n    if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(() => {\n        this.state = STATE_RECOGNIZED;\n        this.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  }\n\n  reset() {\n    clearTimeout(this._timer);\n  }\n\n  emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && (input.eventType & INPUT_END)) {\n      this.manager.emit(`${this.options.event}up`, input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  }\n}\n\n","import { TOUCH_ACTION_COMPUTE } from \"./touchactionjs/touchaction-Consts\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\nimport {DIRECTION_HORIZONTAL} from \"./inputjs/input-consts\";\n\nexport default {\n\t/**\n\t * @private\n\t * set if DOM events are being triggered.\n\t * But this is slower and unused by simple implementations, so disabled by default.\n\t * @type {Boolean}\n\t * @default false\n\t */\n\tdomEvents: false,\n\n\t/**\n\t * @private\n\t * The value for the touchAction property/fallback.\n\t * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t * @type {String}\n\t * @default compute\n\t */\n\ttouchAction: TOUCH_ACTION_COMPUTE,\n\n\t/**\n\t * @private\n\t * @type {Boolean}\n\t * @default true\n\t */\n\tenable: true,\n\n\t/**\n\t * @private\n\t * EXPERIMENTAL FEATURE -- can be removed/changed\n\t * Change the parent input target element.\n\t * If Null, then it is being set the to main element.\n\t * @type {Null|EventTarget}\n\t * @default null\n\t */\n\tinputTarget: null,\n\n\t/**\n\t * @private\n\t * force an input class\n\t * @type {Null|Function}\n\t * @default null\n\t */\n\tinputClass: null,\n\n\t/**\n\t * @private\n\t * Some CSS properties can be used to improve the working of Hammer.\n\t * Add them to this method and they will be set when creating a new Manager.\n\t * @namespace\n\t */\n\tcssProps: {\n\t\t/**\n\t\t * @private\n\t\t * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disable the Windows Phone grippers when pressing an element.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchSelect: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Disables the default callout shown when you touch and hold a touch target.\n\t\t * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t\t * a callout containing information about the link. This property allows you to disable that callout.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\ttouchCallout: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies whether zooming is enabled. Used by IE10>\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tcontentZooming: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t\t * @type {String}\n\t\t * @default 'none'\n\t\t */\n\t\tuserDrag: \"none\",\n\n\t\t/**\n\t\t * @private\n\t\t * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t\t * clickable element in iOS. This property obeys the alpha value, if specified.\n\t\t * @type {String}\n\t\t * @default 'rgba(0,0,0,0)'\n\t\t */\n\t\ttapHighlightColor: \"rgba(0,0,0,0)\",\n\t},\n};\n\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\nexport const preset = [\n  [RotateRecognizer, { enable: false }],\n  [PinchRecognizer, { enable: false }, ['rotate']],\n  [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n  [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n  [TapRecognizer],\n  [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n  [PressRecognizer]\n];\n","import assign from \"./utils/assign\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport createInputInstance from \"./inputjs/create-input-instance\";\nimport each from \"./utils/each\";\nimport inArray from \"./utils/in-array\";\nimport invokeArrayArg from \"./utils/invoke-array-arg\";\nimport splitStr from \"./utils/split-str\";\nimport prefixed from \"./utils/prefixed\";\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport {\n  STATE_BEGAN,\n  STATE_ENDED,\n  STATE_CHANGED,\n  STATE_RECOGNIZED,\n} from \"./recognizerjs/recognizer-consts\";\nimport defaults from \"./defaults\";\n\nconst STOP = 1;\nconst FORCED_STOP = 2;\n\n\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n  const { element } = manager;\n\n  if (!element.style) {\n    return;\n  }\n  let prop;\n\n  each(manager.options.cssProps, (value, name) => {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n  const gestureEvent = document.createEvent(\"Event\");\n\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n\n\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Manager {\n  constructor(element, options) {\n    this.options = assign({}, defaults, options || {});\n\n    this.options.inputTarget = this.options.inputTarget || element;\n\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(this.options.recognizers, item => {\n      const recognizer = this.add(new (item[0])(item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n\t/**\n\t * @private\n\t * set options\n\t * @param {Object} options\n\t * @returns {Manager}\n\t */\n  set(options) {\n    assign(this.options, options);\n\n    // Options that need a little more setup\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * stop recognizing for this session.\n\t * This session will be discarded, when a new [input]start event is fired.\n\t * When forced, the recognizer cycle is stopped immediately.\n\t * @param {Boolean} [force]\n\t */\n  stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  }\n\n\t/**\n\t * @private\n\t * run the recognizers!\n\t * called by the inputHandler function on every movement of the pointers (touches)\n\t * it walks through all the recognizers and tries to detect the gesture that is being made\n\t * @param {Object} inputData\n\t */\n  recognize(inputData) {\n    const { session } = this;\n\n    if (session.stopped) {\n      return;\n    }\n\n    // run the touch-action polyfill\n    this.touchAction.preventDefaults(inputData);\n\n    let recognizer;\n    const { recognizers } = this;\n\n    // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n    let { curRecognizer } = session;\n\n    // reset when the last recognizer is recognized\n    // or when we're in a new session\n    if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    let i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i];\n\n      // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n      if (session.stopped !== FORCED_STOP && (// 1\n        !curRecognizer || recognizer === curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) { // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      }\n\n      // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * get a recognizer by its event name.\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Recognizer|Null}\n\t */\n  get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    const { recognizers } = this;\n\n    for (let i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  }\n\n\t/**\n\t * @private add a recognizer to the manager\n\t * existing recognizers with the same event name will be removed\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer|Manager}\n\t */\n  add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    }\n\n    // remove existing\n    const existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n\n    this.touchAction.update();\n    return recognizer;\n  }\n\n\t/**\n\t * @private\n\t * remove a recognizer by name or instance\n\t * @param {Recognizer|String} recognizer\n\t * @returns {Manager}\n\t */\n  remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    const targetRecognizer = this.get(recognizer);\n\n    // let's make sure this recognizer exists\n    if (recognizer) {\n      const { recognizers } = this;\n      const index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  }\n\n\t/**\n\t * @private\n\t * bind event\n\t * @param {String} events\n\t * @param {Function} handler\n\t * @returns {EventEmitter} this\n\t */\n  on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  }\n\n\t/**\n\t * @private unbind event, leave emit blank to remove all handlers\n\t * @param {String} events\n\t * @param {Function} [handler]\n\t * @returns {EventEmitter} this\n\t */\n  off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    const { handlers } = this;\n\n    each(splitStr(events), event => {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  }\n\n\t/**\n\t * @private emit event to the listeners\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n  emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    }\n\n    // no handlers, so skip it all\n    const handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    let i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  }\n\n\t/**\n\t * @private\n\t * destroy the manager and unbinds all events\n\t * it doesn't unbind dom events, that is the user own responsibility\n\t */\n  destroy() {\n    this.element && toggleCssProps(this, false);\n\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  }\n}\n","import { SUPPORT_POINTER_EVENTS,SUPPORT_ONLY_TOUCH,SUPPORT_TOUCH } from './input-consts';\nimport inputHandler from './input-handler';\nimport PointerEventInput from '../input/pointerevent';\nimport TouchInput from '../input/touch';\nimport MouseInput from '../input/mouse';\nimport TouchMouseInput from '../input/touchmouse';\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nexport default function createInputInstance(manager) {\n  let Type;\n  // let inputClass = manager.options.inputClass;\n  let { options:{ inputClass } } = manager;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new (Type)(manager, inputHandler);\n}\n","import {\n    INPUT_START,\n    INPUT_MOVE,\n    INPUT_END,\n    INPUT_CANCEL,\n    INPUT_TYPE_TOUCH\n} from '../inputjs/input-consts';\nimport Input from '../inputjs/input-constructor';\nimport toArray from '../utils/to-array';\nimport uniqueArray from '../utils/unique-array';\n\nconst SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\n\nconst SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nconst SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\nexport default class SingleTouchInput extends Input {\n  constructor() {\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\n    super(...arguments);\n    this.started = false;\n  }\n\n  handler(ev) {\n    let type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n    // should we handle the touch events?\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    let touches = normalizeSingleTouches.call(this, ev, type);\n\n    // when done, reset the started state\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  }\n}\n\n/**\n * @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n  let all = toArray(ev.touches);\n  let changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n","/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nexport default function deprecate(method, name, message) {\n  let deprecationMessage = `DEPRECATED METHOD: ${name}\\n${message} AT \\n`;\n  return function() {\n    let e = new Error('get-stack-trace');\n    let stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '')\n        .replace(/^\\s+at\\s+/gm, '')\n        .replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n\n    let log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n","import deprecate from './deprecate';\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\nconst extend = deprecate((dest, src, merge) => {\n  let keys = Object.keys(src);\n  let i = 0;\n  while (i < keys.length) {\n    if (!merge || (merge && dest[keys[i]] === undefined)) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\nexport default extend;\n","import deprecate from './deprecate';\nimport extend from './extend';\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nconst merge = deprecate((dest, src) => {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\nexport default merge;\n","import assign from './assign';\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nexport default function inherit(child, base, properties) {\n  let baseP = base.prototype;\n  let childP;\n\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign(childP, properties);\n  }\n}\n","/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nexport default function bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n","import Manager from \"./manager\";\nimport defaults, { preset } from \"./defaults\";\nimport assign from './utils/assign';\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nexport default class Hammer {\n\t/**\n   * @private\n   * @const {string}\n   */\n\tstatic VERSION = \"#__VERSION__#\";\n\tstatic DIRECTION_ALL = DIRECTION_ALL;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic DIRECTION_LEFT = DIRECTION_LEFT;\n\tstatic DIRECTION_RIGHT = DIRECTION_RIGHT;\n\tstatic DIRECTION_UP = DIRECTION_UP;\n\tstatic DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n\tstatic DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n\tstatic DIRECTION_NONE = DIRECTION_NONE;\n\tstatic DIRECTION_DOWN = DIRECTION_DOWN;\n\tstatic INPUT_START = INPUT_START;\n\tstatic INPUT_MOVE = INPUT_MOVE;\n  static INPUT_END = INPUT_END;\n\tstatic INPUT_CANCEL = INPUT_CANCEL;\n\tstatic STATE_POSSIBLE = STATE_POSSIBLE;\n\tstatic STATE_BEGAN = STATE_BEGAN;\n\tstatic STATE_CHANGED = STATE_CHANGED;\n\tstatic STATE_ENDED = STATE_ENDED;\n\tstatic STATE_RECOGNIZED = STATE_RECOGNIZED;\n\tstatic STATE_CANCELLED = STATE_CANCELLED;\n\tstatic STATE_FAILED = STATE_FAILED;\n\tstatic Manager = Manager;\n\tstatic Input = Input;\n\tstatic TouchAction = TouchAction;\n\tstatic TouchInput = TouchInput;\n\tstatic MouseInput = MouseInput;\n\tstatic PointerEventInput = PointerEventInput;\n\tstatic TouchMouseInput = TouchMouseInput;\n\tstatic SingleTouchInput = SingleTouchInput;\n\tstatic Recognizer = Recognizer;\n\tstatic AttrRecognizer = AttrRecognizer;\n\tstatic Tap = TapRecognizer;\n\tstatic Pan = PanRecognizer;\n\tstatic Swipe = SwipeRecognizer;\n\tstatic Pinch = PinchRecognizer;\n\tstatic Rotate = RotateRecognizer;\n\tstatic Press = PressRecognizer;\n\tstatic on = addEventListeners;\n\tstatic off = removeEventListeners;\n\tstatic each = each;\n\tstatic merge = merge;\n\tstatic extend = extend;\n\tstatic bindFn = bindFn;\n\tstatic assign = assign;\n\tstatic inherit = inherit;\n\tstatic bindFn = bindFn;\n\tstatic prefixed = prefixed;\n\tstatic toArray = toArray;\n\tstatic inArray = inArray;\n\tstatic uniqueArray = uniqueArray;\n\tstatic splitStr = splitStr;\n\tstatic boolOrFn = boolOrFn;\n\tstatic hasParent = hasParent;\n\tstatic addEventListeners = addEventListeners;\n\tstatic removeEventListeners = removeEventListeners;\n\tstatic defaults = assign({}, defaults, { preset });\n\tconstructor(element, options = {}) {\n\t\treturn new Manager(element, {\n\t\t\trecognizers: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        ...preset\n\t\t\t],\n\t\t\t...options,\n\t\t});\n\t}\n}\n","\nimport Hammer from \"./hammer\";\nimport assign from \"./utils/assign\";\n\nimport {\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n} from \"./inputjs/input-consts\";\nimport {\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n} from \"./recognizerjs/recognizer-consts\";\n\nimport Manager from \"./manager\";\nimport Input from \"./inputjs/input-constructor\";\nimport TouchAction from \"./touchactionjs/touchaction-constructor\";\nimport TouchInput from \"./input/touch\";\nimport MouseInput from \"./input/mouse\";\nimport PointerEventInput from \"./input/pointerevent\";\nimport SingleTouchInput from \"./input/singletouch\";\nimport TouchMouseInput from \"./input/touchmouse\";\n\nimport Recognizer from \"./recognizerjs/recognizer-constructor\";\nimport AttrRecognizer from \"./recognizers/attribute\";\nimport TapRecognizer from \"./recognizers/tap\";\nimport PanRecognizer from \"./recognizers/pan\";\nimport SwipeRecognizer from \"./recognizers/swipe\";\nimport PinchRecognizer from \"./recognizers/pinch\";\nimport RotateRecognizer from \"./recognizers/rotate\";\nimport PressRecognizer from \"./recognizers/press\";\n\nimport addEventListeners from \"./utils/add-event-listeners\";\nimport removeEventListeners from \"./utils/remove-event-listeners\";\nimport each from \"./utils/each\";\nimport merge from \"./utils/merge\";\nimport extend from \"./utils/extend\";\nimport inherit from \"./utils/inherit\";\nimport bindFn from \"./utils/bind-fn\";\nimport prefixed from \"./utils/prefixed\";\nimport toArray from \"./utils/to-array\";\nimport uniqueArray from \"./utils/unique-array\";\nimport splitStr from \"./utils/split-str\";\nimport inArray from \"./utils/in-array\";\nimport boolOrFn from \"./utils/bool-or-fn\";\nimport hasParent from \"./utils/has-parent\";\n\n// this prevents errors when Hammer is loaded in the presence of an AMD\n//  style loader but by script tag, not by the loader.\n\nconst defaults = Hammer.defaults;\n\nexport {\n  Hammer as default,\n  INPUT_START,\n  INPUT_MOVE,\n  INPUT_END,\n  INPUT_CANCEL,\n  STATE_POSSIBLE,\n  STATE_BEGAN,\n  STATE_CHANGED,\n  STATE_ENDED,\n  STATE_RECOGNIZED,\n  STATE_CANCELLED,\n  STATE_FAILED,\n\n  DIRECTION_NONE,\n  DIRECTION_LEFT,\n  DIRECTION_RIGHT,\n  DIRECTION_UP,\n  DIRECTION_DOWN,\n  DIRECTION_HORIZONTAL,\n  DIRECTION_VERTICAL,\n  DIRECTION_ALL,\n  Manager,\n  Input,\n  TouchAction,\n  TouchInput,\n  MouseInput,\n  PointerEventInput,\n  TouchMouseInput,\n  SingleTouchInput,\n  Recognizer,\n  AttrRecognizer,\n  TapRecognizer as Tap,\n  PanRecognizer as Pan,\n  SwipeRecognizer as Swipe,\n  PinchRecognizer as Pinch,\n  RotateRecognizer as Rotate,\n  PressRecognizer as Press,\n  addEventListeners as on,\n  removeEventListeners as off,\n  each,\n  merge,\n  extend,\n  assign,\n  inherit,\n  bindFn,\n  prefixed,\n  toArray,\n  inArray,\n  uniqueArray,\n  splitStr,\n  boolOrFn,\n  hasParent,\n  addEventListeners,\n  removeEventListeners,\n  defaults,\n};\n","import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\n\nexport const CONTENT_TOUCHES_DELAY = 240;\nexport const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;\nexport const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;\nexport const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;\nexport const DEG_RAD = Math.PI / 180;\n\n// Map Hammer values to RNGH\nexport const EventMap = {\n  [Hammer.INPUT_START]: State.BEGAN,\n  [Hammer.INPUT_MOVE]: State.ACTIVE,\n  [Hammer.INPUT_END]: State.END,\n  [Hammer.INPUT_CANCEL]: State.FAILED,\n} as const;\n\nexport const Direction = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n};\n\nexport const DirectionMap = {\n  [Hammer.DIRECTION_RIGHT]: Direction.RIGHT,\n  [Hammer.DIRECTION_LEFT]: Direction.LEFT,\n  [Hammer.DIRECTION_UP]: Direction.UP,\n  [Hammer.DIRECTION_DOWN]: Direction.DOWN,\n};\n\nexport const HammerInputNames = {\n  [Hammer.INPUT_START]: 'START',\n  [Hammer.INPUT_MOVE]: 'MOVE',\n  [Hammer.INPUT_END]: 'END',\n  [Hammer.INPUT_CANCEL]: 'CANCEL',\n};\nexport const HammerDirectionNames = {\n  [Hammer.DIRECTION_HORIZONTAL]: 'HORIZONTAL',\n  [Hammer.DIRECTION_UP]: 'UP',\n  [Hammer.DIRECTION_DOWN]: 'DOWN',\n  [Hammer.DIRECTION_VERTICAL]: 'VERTICAL',\n  [Hammer.DIRECTION_NONE]: 'NONE',\n  [Hammer.DIRECTION_ALL]: 'ALL',\n  [Hammer.DIRECTION_RIGHT]: 'RIGHT',\n  [Hammer.DIRECTION_LEFT]: 'LEFT',\n};\n","export class GesturePropError extends Error {\n  constructor(name: string, value: unknown, expectedType: string) {\n    super(\n      `Invalid property \\`${name}: ${value}\\` expected \\`${expectedType}\\``\n    );\n  }\n}\n","import { ValueOf } from '../typeUtils';\nimport { Gestures } from '../RNGestureHandlerModule.web';\n\nconst gestures: Record<number, InstanceType<ValueOf<typeof Gestures>>> = {};\n\nexport function getHandler(tag: number) {\n  if (tag in gestures) return gestures[tag];\n\n  throw new Error(`No handler for tag ${tag}`);\n}\n\nexport function createGestureHandler(\n  handlerTag: number,\n  handler: InstanceType<ValueOf<typeof Gestures>>\n) {\n  if (handlerTag in gestures) {\n    throw new Error(`Handler with tag ${handlerTag} already exists`);\n  }\n  gestures[handlerTag] = handler;\n  // @ts-ignore no types for web handlers yet\n  gestures[handlerTag].handlerTag = handlerTag;\n}\n\nexport function dropGestureHandler(handlerTag: number) {\n  getHandler(handlerTag).destroy();\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete gestures[handlerTag];\n}\n\nexport function getNodes() {\n  return { ...gestures };\n}\n","/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport { State } from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\n\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\n\nexport type Config = Partial<{\n  enabled: boolean;\n  minPointers: number;\n  maxPointers: number;\n  minDist: number;\n  minDistSq: number;\n  minVelocity: number;\n  minVelocitySq: number;\n  maxDist: number;\n  maxDistSq: number;\n  failOffsetXStart: number;\n  failOffsetYStart: number;\n  failOffsetXEnd: number;\n  failOffsetYEnd: number;\n  activeOffsetXStart: number;\n  activeOffsetXEnd: number;\n  activeOffsetYStart: number;\n  activeOffsetYEnd: number;\n  waitFor: any[] | null;\n}>;\n\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\n\nlet gestureInstances = 0;\n\nabstract class GestureHandler {\n  public handlerTag: any;\n  public isGestureRunning = false;\n  public view: number | null = null;\n  protected hasCustomActivationCriteria: boolean;\n  protected hasGestureFailed = false;\n  protected hammer: HammerManager | null = null;\n  protected initialRotation: number | null = null;\n  protected __initialX: any;\n  protected __initialY: any;\n  protected config: Config = {};\n  protected previousState: State = State.UNDETERMINED;\n  private pendingGestures: Record<string, this> = {};\n  private oldState: State = State.UNDETERMINED;\n  private lastSentState: State | null = null;\n  private gestureInstance: number;\n  private _stillWaiting: any;\n  private propsRef: any;\n  private ref: any;\n\n  abstract get name(): string;\n\n  get id() {\n    return `${this.name}${this.gestureInstance}`;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this.gestureInstance = gestureInstances++;\n    this.hasCustomActivationCriteria = false;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(_gesture: this) {}\n\n  removePendingGesture(id: string) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture: this) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent(\n    _config: any,\n    _recognizer: any,\n    _event: any\n  ): { failed?: boolean; success?: boolean } {\n    return { success: true };\n  }\n\n  get NativeGestureClass(): RecognizerStatic {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(_config: Config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = ensureConfig({ enabled, ...props });\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop(false);\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type: keyof typeof EventMap): State {\n    // @ts-ignore TODO(TS) check if this is needed\n    if (type == 0) {\n      return 0;\n    }\n    return EventMap[type];\n  }\n\n  transformEventData(event: HammerInputExt) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: this.oldState,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(_event: HammerInputExt) {\n    return {};\n  }\n\n  sendEvent = (nativeEvent: HammerInputExt) => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    } = this.propsRef.current;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod(onGestureHandlerEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state as State;\n      invokeNullableMethod(onGestureHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event: HammerInputExt) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\n  onGestureEnded(event: HammerInputExt) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event: HammerInputExt) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }: HammerInputExt) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n    this.hammer = new Hammer.Manager(this.view as any);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    // @ts-ignore TODO(TS)\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent((ev as unknown) as HammerInputExt);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\n    if (!this.isDiscrete) {\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\n        this.onStart((event as unknown) as HammerInputExt)\n      );\n      this.hammer!.on(\n        `${this.name}end ${this.name}cancel`,\n        (event: HammerInput) => {\n          this.onGestureEnded((event as unknown) as HammerInputExt);\n        }\n      );\n    }\n    this.hammer!.on(this.name, (ev: HammerInput) =>\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n  }\n\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer!.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer: any, inputData: any) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this.hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      // @ts-ignore FIXME(TS)\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    // @ts-ignore FIXME(TS)\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(_inputData: any) {}\n}\n\n// TODO(TS) investigate this method\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(\n  method:\n    | ((event: NativeEvent) => void)\n    | { __getHandler: () => (event: NativeEvent) => void }\n    | { __nodeConfig: { argMapping: any } },\n  event: NativeEvent\n) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const index in argMapping) {\n              const [key, value] = argMapping[index];\n              if (key in event.nativeEvent) {\n                // @ts-ignore fix method type\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Validate the props\nfunction ensureConfig(config: Config): Required<Config> {\n  const props = { ...config };\n\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\n  if ('minDist' in config) {\n    props.minDist = config.minDist;\n    props.minDistSq = props.minDist! * props.minDist!;\n  }\n  if ('minVelocity' in config) {\n    props.minVelocity = config.minVelocity;\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\n  }\n  if ('maxDist' in config) {\n    props.maxDist = config.maxDist;\n    props.maxDistSq = config.maxDist! * config.maxDist!;\n  }\n  if ('waitFor' in config) {\n    props.waitFor = asArray(config.waitFor)\n      .map(({ handlerTag }: { handlerTag: number }) =>\n        NodeManager.getHandler(handlerTag)\n      )\n      .filter((v) => v);\n  } else {\n    props.waitFor = null;\n  }\n\n  const configProps = [\n    'minPointers',\n    'maxPointers',\n    'minDist',\n    'maxDist',\n    'maxDistSq',\n    'minVelocitySq',\n    'minDistSq',\n    'minVelocity',\n    'failOffsetXStart',\n    'failOffsetYStart',\n    'failOffsetXEnd',\n    'failOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n  ] as const;\n  configProps.forEach((prop: typeof configProps[number]) => {\n    if (typeof props[prop] === 'undefined') {\n      props[prop] = Number.NaN;\n    }\n  });\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\n}\n\nfunction asArray<T>(value: T | T[]) {\n  // TODO(TS) use config.waitFor type\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n","/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\nimport { PixelRatio } from 'react-native';\n\nabstract class DraggingGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  transformNativeEvent({\n    deltaX,\n    deltaY,\n    velocityX,\n    velocityY,\n    center: { x, y },\n  }: HammerInputExt) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const ratio = PixelRatio.get();\n    return {\n      translationX: deltaX - (this.__initialX || 0),\n      translationY: deltaY - (this.__initialY || 0),\n      absoluteX: x,\n      absoluteY: y,\n      velocityX: velocityX * ratio,\n      velocityY: velocityY * ratio,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n}\n\nexport default DraggingGestureHandler;\n","// TODO(TS) remove if not necessary after rewrite\nexport const isnan = (v: unknown) => Number.isNaN(v);\n\n// TODO(TS) remove if not necessary after rewrite\nexport const isValidNumber = (v: unknown) =>\n  typeof v === 'number' && !Number.isNaN(v);\n\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\n  !isnan(limit) &&\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\n\nexport function fireAfterInterval(\n  method: () => void,\n  interval?: number | boolean\n) {\n  if (!interval) {\n    method();\n    return null;\n  }\n  return setTimeout(() => method(), interval);\n}\n","/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n","/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport {\n  CONTENT_TOUCHES_DELAY,\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\n  HammerInputNames,\n} from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { Config, HammerInputExt } from './GestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  private visualFeedbackTimer: any;\n  private initialEvent: HammerInputExt | null = null;\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    // @ts-ignore FIXME(TS)\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  shouldDelayTouches = true;\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({\n    shouldCancelWhenOutside,\n    maxDistSq,\n  }: Config & { shouldCancelWhenOutside: boolean }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type: keyof typeof HammerInputNames): State {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\n    }[type];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev: HammerInputExt) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev: HammerInputExt) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({\n      ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true,\n    });\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.isGestureRunning) {\n      if (ev.isFinal) {\n        let timeout;\n        if (this.visualFeedbackTimer) {\n          // Aesthetic timing for a quick tap.\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n          this.initialEvent = null;\n        }\n        fireAfterInterval(() => {\n          this.sendEvent({\n            ...ev,\n            eventType: Hammer.INPUT_END,\n            isFinal: true,\n          });\n          // @ts-ignore -- this should explicitly support undefined\n          this.onGestureEnded();\n        }, timeout);\n      } else {\n        this.sendEvent({\n          ...ev,\n          eventType: Hammer.INPUT_MOVE,\n          isFinal: false,\n        });\n      }\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n}\nexport default PressGestureHandler;\n","/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport PressGestureHandler from './PressGestureHandler';\nimport { isnan, isValidNumber } from './utils';\nimport { Config } from './GestureHandler';\nimport { HammerInputNames } from './constants';\n\nclass LongPressGestureHandler extends PressGestureHandler {\n  get minDurationMs(): number {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\n    return !isValidNumber(maxDistSq);\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  getState(type: keyof typeof HammerInputNames) {\n    return {\n      [Hammer.INPUT_START]: State.ACTIVE,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.FAILED,\n    }[type];\n  }\n}\n\nexport default LongPressGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport {\n  EventMap,\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\n} from './constants';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\nimport { State } from '../State';\n\nimport { Config, HammerInputExt } from './GestureHandler';\nclass PanGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'pan';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pan;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      direction: this.getDirection(),\n    };\n  }\n\n  getState(type: keyof typeof EventMap) {\n    const nextState = super.getState(type);\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\n    if (\n      this.previousState === State.UNDETERMINED &&\n      nextState === State.ACTIVE\n    ) {\n      return State.BEGAN;\n    }\n    return nextState;\n  }\n\n  getDirection() {\n    const config = this.getConfig();\n    const {\n      activeOffsetXStart,\n      activeOffsetXEnd,\n      activeOffsetYStart,\n      activeOffsetYEnd,\n      minDist,\n    } = config;\n    let directions: number[] = [];\n    let horizontalDirections = [];\n\n    if (!isnan(minDist)) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    if (!isnan(activeOffsetXStart))\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\n    if (!isnan(activeOffsetXEnd))\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\n    if (horizontalDirections.length === 2)\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\n\n    directions = directions.concat(horizontalDirections);\n    let verticalDirections = [];\n\n    if (!isnan(activeOffsetYStart))\n      verticalDirections.push(Hammer.DIRECTION_UP);\n    if (!isnan(activeOffsetYEnd))\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\n\n    if (verticalDirections.length === 2)\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\n\n    directions = directions.concat(verticalDirections);\n\n    if (!directions.length) {\n      return Hammer.DIRECTION_NONE;\n    }\n    if (\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\n      directions[1] === Hammer.DIRECTION_VERTICAL\n    ) {\n      return Hammer.DIRECTION_ALL;\n    }\n    if (horizontalDirections.length && verticalDirections.length) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    return directions[0];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        minDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { deltaX, deltaY }: HammerInputExt,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.failOffsetXStart) &&\n        deltaX < criteria.failOffsetXStart) ||\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\n      (!isnan(criteria.failOffsetYStart) &&\n        deltaY < criteria.failOffsetYStart) ||\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\n    );\n  }\n\n  shouldActivateUnderCustomCriteria(\n    { deltaX, deltaY, velocity }: any,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.activeOffsetXStart) &&\n        deltaX < criteria.activeOffsetXStart) ||\n      (!isnan(criteria.activeOffsetXEnd) &&\n        deltaX > criteria.activeOffsetXEnd) ||\n      (!isnan(criteria.activeOffsetYStart) &&\n        deltaY < criteria.activeOffsetYStart) ||\n      (!isnan(criteria.activeOffsetYEnd) &&\n        deltaY > criteria.activeOffsetYEnd) ||\n      TEST_MIN_IF_NOT_NAN(\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\n        criteria.minDistSq\n      ) ||\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\n    );\n  }\n\n  shouldMultiFingerPanFail({\n    pointerLength,\n    scale,\n    deltaRotation,\n  }: {\n    deltaRotation: number;\n    pointerLength: number;\n    scale: number;\n  }) {\n    if (pointerLength <= 1) {\n      return false;\n    }\n\n    // Test if the pan had too much pinching or rotating.\n    const deltaScale = Math.abs(scale - 1);\n    const absDeltaRotation = Math.abs(deltaRotation);\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHasCustomActivationCriteria(\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\n  ) {\n    return (\n      isValidNumber(criteria.minDistSq) ||\n      isValidNumber(criteria.minVelocityX) ||\n      isValidNumber(criteria.minVelocityY) ||\n      isValidNumber(criteria.minVelocitySq) ||\n      isValidNumber(criteria.activeOffsetXStart) ||\n      isValidNumber(criteria.activeOffsetXEnd) ||\n      isValidNumber(criteria.activeOffsetYStart) ||\n      isValidNumber(criteria.activeOffsetYEnd)\n    );\n  }\n\n  isGestureEnabledForEvent(\n    props: any,\n    _recognizer: any,\n    inputData: HammerInputExt & { deltaRotation: number }\n  ) {\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\n      return { failed: true };\n    }\n\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\n    if (\n      this.hasCustomActivationCriteria &&\n      this.shouldActivateUnderCustomCriteria(\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\n        props\n      )\n    ) {\n      if (\n        this.shouldMultiFingerPanFail({\n          pointerLength: inputData.maxPointers,\n          scale: inputData.scale,\n          deltaRotation: inputData.deltaRotation,\n        })\n      ) {\n        return {\n          failed: true,\n        };\n      }\n      return { success: true };\n    }\n    return { success: false };\n  }\n}\n\nexport default PanGestureHandler;\n","import GestureHandler from './GestureHandler';\n\n/**\n * The base class for **Rotation** and **Pinch** gesture handlers.\n */\nabstract class IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\n    return super.updateGestureConfig({\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    if (pointerLength > maxPointers) {\n      return { failed: true };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount,\n    };\n  }\n}\nexport default IndiscreteGestureHandler;\n","import Hammer from '@egjs/hammerjs';\nimport { HammerInputExt } from './GestureHandler';\n\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass PinchGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'pinch';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pinch;\n  }\n\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\n    return {\n      focalX: center.x,\n      focalY: center.y,\n      velocity,\n      scale,\n    };\n  }\n}\n\nexport default PinchGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport { DEG_RAD } from './constants';\nimport { HammerInputExt } from './GestureHandler';\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass RotationGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'rotate';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Rotate;\n  }\n\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\n    return {\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\n      anchorX: center.x,\n      anchorY: center.y,\n      velocity,\n    };\n  }\n}\nexport default RotationGestureHandler;\n","import Hammer from '@egjs/hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  private _shouldFireEndEvent: HammerInputExt | null = null;\n  private _timer: any;\n  private _multiTapTimer: any; // TODO unused?\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    // @ts-ignore TODO(TS) trace down config\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = (ev: HammerInputExt) => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev: HammerInput) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      // @ts-ignore TODO(TS) trace down config\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        // @ts-ignore TODO(TS) trace down config\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : // @ts-ignore TODO(TS) trace down config\n            this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props: any) {\n    clearTimeout(this._timer);\n    // @ts-ignore TODO(TS) check how onGestureEnded works\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(_gesture: any) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n","import { Direction } from './web/constants';\nimport FlingGestureHandler from './web/FlingGestureHandler';\nimport LongPressGestureHandler from './web/LongPressGestureHandler';\nimport NativeViewGestureHandler from './web/NativeViewGestureHandler';\nimport * as NodeManager from './web/NodeManager';\nimport PanGestureHandler from './web/PanGestureHandler';\nimport PinchGestureHandler from './web/PinchGestureHandler';\nimport RotationGestureHandler from './web/RotationGestureHandler';\nimport TapGestureHandler from './web/TapGestureHandler';\n\nexport const Gestures = {\n  PanGestureHandler,\n  RotationGestureHandler,\n  PinchGestureHandler,\n  TapGestureHandler,\n  NativeViewGestureHandler,\n  LongPressGestureHandler,\n  FlingGestureHandler,\n  // ForceTouchGestureHandler,\n};\n\nexport default {\n  Direction,\n  handleSetJSResponder(tag: number, blockNativeResponder: boolean) {\n    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);\n  },\n  handleClearJSResponder() {\n    console.warn('handleClearJSResponder: ');\n  },\n  createGestureHandler<T>(\n    handlerName: keyof typeof Gestures,\n    handlerTag: number,\n    config: T\n  ) {\n    //TODO(TS) extends config\n    if (!(handlerName in Gestures))\n      throw new Error(\n        `react-native-gesture-handler: ${handlerName} is not supported on web.`\n      );\n    const GestureClass = Gestures[handlerName];\n    NodeManager.createGestureHandler(handlerTag, new GestureClass());\n    this.updateGestureHandler(handlerTag, config);\n  },\n  attachGestureHandler(\n    handlerTag: number,\n    newView: number,\n    propsRef: React.RefObject<unknown>\n  ) {\n    NodeManager.getHandler(handlerTag).setView(newView, propsRef);\n  },\n  updateGestureHandler(handlerTag: number, newConfig: any) {\n    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);\n  },\n  getGestureHandlerNode(handlerTag: number) {\n    return NodeManager.getHandler(handlerTag);\n  },\n  dropGestureHandler(handlerTag: number) {\n    NodeManager.dropGestureHandler(handlerTag);\n  },\n};\n"],"sourceRoot":""}